// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: identity_links.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkAutoLinkByEmail = `-- name: BulkAutoLinkByEmail :execrows
INSERT INTO identity_accounts (identity_id, account_id, link_reason, confidence, updated_at)
SELECT DISTINCT ON (au.id)
  i.id,
  au.id,
  'auto_email',
  1.0,
  now()
FROM accounts au
JOIN identities i ON lower(trim(i.primary_email)) = lower(trim(au.email))
LEFT JOIN identity_accounts ia ON ia.account_id = au.id
WHERE au.source_kind = $1
  AND au.source_name = $2
  AND au.email <> ''
  AND i.primary_email <> ''
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND ia.id IS NULL
ORDER BY au.id, i.id ASC
ON CONFLICT (account_id) DO NOTHING
`

type BulkAutoLinkByEmailParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) BulkAutoLinkByEmail(ctx context.Context, arg BulkAutoLinkByEmailParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkAutoLinkByEmail, arg.SourceKind, arg.SourceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createIdentityLink = `-- name: CreateIdentityLink :one

INSERT INTO identity_accounts (identity_id, account_id, link_reason, confidence, updated_at)
VALUES ($1, $2, $3, 1.0, now())
ON CONFLICT (account_id) DO UPDATE SET
  identity_id = EXCLUDED.identity_id,
  link_reason = EXCLUDED.link_reason,
  confidence = EXCLUDED.confidence,
  updated_at = EXCLUDED.updated_at
RETURNING
  id,
  identity_id AS idp_user_id,
  account_id AS app_user_id,
  link_reason,
  created_at
`

type CreateIdentityLinkParams struct {
	IdentityID int64  `json:"identity_id"`
	AccountID  int64  `json:"account_id"`
	LinkReason string `json:"link_reason"`
}

type CreateIdentityLinkRow struct {
	ID         int64              `json:"id"`
	IdpUserID  int64              `json:"idp_user_id"`
	AppUserID  int64              `json:"app_user_id"`
	LinkReason string             `json:"link_reason"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

// Compatibility query names on top of identity_accounts.
func (q *Queries) CreateIdentityLink(ctx context.Context, arg CreateIdentityLinkParams) (CreateIdentityLinkRow, error) {
	row := q.db.QueryRow(ctx, createIdentityLink, arg.IdentityID, arg.AccountID, arg.LinkReason)
	var i CreateIdentityLinkRow
	err := row.Scan(
		&i.ID,
		&i.IdpUserID,
		&i.AppUserID,
		&i.LinkReason,
		&i.CreatedAt,
	)
	return i, err
}

const getIdentityLinkByAppUser = `-- name: GetIdentityLinkByAppUser :one
SELECT
  ia.id,
  ia.identity_id AS idp_user_id,
  ia.account_id AS app_user_id,
  ia.link_reason,
  ia.created_at
FROM identity_accounts ia
WHERE ia.account_id = $1
`

type GetIdentityLinkByAppUserRow struct {
	ID         int64              `json:"id"`
	IdpUserID  int64              `json:"idp_user_id"`
	AppUserID  int64              `json:"app_user_id"`
	LinkReason string             `json:"link_reason"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetIdentityLinkByAppUser(ctx context.Context, accountID int64) (GetIdentityLinkByAppUserRow, error) {
	row := q.db.QueryRow(ctx, getIdentityLinkByAppUser, accountID)
	var i GetIdentityLinkByAppUserRow
	err := row.Scan(
		&i.ID,
		&i.IdpUserID,
		&i.AppUserID,
		&i.LinkReason,
		&i.CreatedAt,
	)
	return i, err
}

const listLinkedAppUsersForIdPUser = `-- name: ListLinkedAppUsersForIdPUser :many
SELECT au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id, au.status
FROM accounts au
JOIN identity_accounts ia ON ia.account_id = au.id
WHERE ia.identity_id = $1
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
ORDER BY au.source_kind, au.source_name, au.external_id
`

func (q *Queries) ListLinkedAppUsersForIdPUser(ctx context.Context, identityID int64) ([]Account, error) {
	rows, err := q.db.Query(ctx, listLinkedAppUsersForIdPUser, identityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

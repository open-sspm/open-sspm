// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: identity_links.sql

package gen

import (
	"context"
)

const bulkAutoLinkByEmail = `-- name: BulkAutoLinkByEmail :execrows
INSERT INTO identity_links (idp_user_id, app_user_id, link_reason)
SELECT DISTINCT ON (au.id)
  iu.id,
  au.id,
  'auto_email'
FROM app_users au
JOIN idp_users iu ON lower(iu.email) = lower(au.email)
LEFT JOIN identity_links il ON il.app_user_id = au.id
WHERE au.source_kind = $1
  AND au.source_name = $2
  AND au.email <> ''
  AND iu.email <> ''
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND iu.expired_at IS NULL
  AND iu.last_observed_run_id IS NOT NULL
  AND il.id IS NULL
ORDER BY au.id, (iu.status = 'ACTIVE') DESC, iu.id ASC
ON CONFLICT (app_user_id) DO NOTHING
`

type BulkAutoLinkByEmailParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) BulkAutoLinkByEmail(ctx context.Context, arg BulkAutoLinkByEmailParams) (int64, error) {
	result, err := q.db.Exec(ctx, bulkAutoLinkByEmail, arg.SourceKind, arg.SourceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createIdentityLink = `-- name: CreateIdentityLink :one
INSERT INTO identity_links (idp_user_id, app_user_id, link_reason)
VALUES ($1, $2, $3)
ON CONFLICT (app_user_id) DO UPDATE SET
  idp_user_id = EXCLUDED.idp_user_id,
  link_reason = EXCLUDED.link_reason
RETURNING id, idp_user_id, app_user_id, link_reason, created_at
`

type CreateIdentityLinkParams struct {
	IdpUserID  int64  `json:"idp_user_id"`
	AppUserID  int64  `json:"app_user_id"`
	LinkReason string `json:"link_reason"`
}

func (q *Queries) CreateIdentityLink(ctx context.Context, arg CreateIdentityLinkParams) (IdentityLink, error) {
	row := q.db.QueryRow(ctx, createIdentityLink, arg.IdpUserID, arg.AppUserID, arg.LinkReason)
	var i IdentityLink
	err := row.Scan(
		&i.ID,
		&i.IdpUserID,
		&i.AppUserID,
		&i.LinkReason,
		&i.CreatedAt,
	)
	return i, err
}

const getIdentityLinkByAppUser = `-- name: GetIdentityLinkByAppUser :one
SELECT id, idp_user_id, app_user_id, link_reason, created_at FROM identity_links WHERE app_user_id = $1
`

func (q *Queries) GetIdentityLinkByAppUser(ctx context.Context, appUserID int64) (IdentityLink, error) {
	row := q.db.QueryRow(ctx, getIdentityLinkByAppUser, appUserID)
	var i IdentityLink
	err := row.Scan(
		&i.ID,
		&i.IdpUserID,
		&i.AppUserID,
		&i.LinkReason,
		&i.CreatedAt,
	)
	return i, err
}

const listLinkedAppUsersForIdPUser = `-- name: ListLinkedAppUsersForIdPUser :many
SELECT au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id
FROM app_users au
JOIN identity_links il ON il.app_user_id = au.id
WHERE il.idp_user_id = $1
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
ORDER BY au.source_kind, au.source_name, au.external_id
`

func (q *Queries) ListLinkedAppUsersForIdPUser(ctx context.Context, idpUserID int64) ([]AppUser, error) {
	rows, err := q.db.Query(ctx, listLinkedAppUsersForIdPUser, idpUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUser
	for rows.Next() {
		var i AppUser
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

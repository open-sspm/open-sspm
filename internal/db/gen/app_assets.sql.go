// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: app_assets.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAppAssetsBySourceAndQueryAndKind = `-- name: CountAppAssetsBySourceAndQueryAndKind :one
SELECT count(*)
FROM app_assets aa
WHERE
  aa.source_kind = $1::text
  AND aa.source_name = $2::text
  AND aa.expired_at IS NULL
  AND aa.last_observed_run_id IS NOT NULL
  AND (
    $3::text = ''
    OR aa.asset_kind = $3::text
  )
  AND (
    $4::text = ''
    OR aa.display_name ILIKE ('%' || $4::text || '%')
    OR aa.external_id ILIKE ('%' || $4::text || '%')
    OR aa.parent_external_id ILIKE ('%' || $4::text || '%')
  )
`

type CountAppAssetsBySourceAndQueryAndKindParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	AssetKind  string `json:"asset_kind"`
	Query      string `json:"query"`
}

func (q *Queries) CountAppAssetsBySourceAndQueryAndKind(ctx context.Context, arg CountAppAssetsBySourceAndQueryAndKindParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppAssetsBySourceAndQueryAndKind,
		arg.SourceKind,
		arg.SourceName,
		arg.AssetKind,
		arg.Query,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const expireAppAssetsNotSeenInRunBySource = `-- name: ExpireAppAssetsNotSeenInRunBySource :execrows
UPDATE app_assets
SET
  expired_at = now(),
  expired_run_id = $1::bigint
WHERE source_kind = $2::text
  AND source_name = $3::text
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND (
    seen_in_run_id <> $1::bigint
    OR seen_in_run_id IS NULL
  )
`

type ExpireAppAssetsNotSeenInRunBySourceParams struct {
	ExpiredRunID int64  `json:"expired_run_id"`
	SourceKind   string `json:"source_kind"`
	SourceName   string `json:"source_name"`
}

func (q *Queries) ExpireAppAssetsNotSeenInRunBySource(ctx context.Context, arg ExpireAppAssetsNotSeenInRunBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, expireAppAssetsNotSeenInRunBySource, arg.ExpiredRunID, arg.SourceKind, arg.SourceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAppAssetByID = `-- name: GetAppAssetByID :one
SELECT id, source_kind, source_name, asset_kind, external_id, parent_external_id, display_name, status, created_at_source, updated_at_source, raw_json, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, created_at, updated_at
FROM app_assets
WHERE id = $1
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

func (q *Queries) GetAppAssetByID(ctx context.Context, id int64) (AppAsset, error) {
	row := q.db.QueryRow(ctx, getAppAssetByID, id)
	var i AppAsset
	err := row.Scan(
		&i.ID,
		&i.SourceKind,
		&i.SourceName,
		&i.AssetKind,
		&i.ExternalID,
		&i.ParentExternalID,
		&i.DisplayName,
		&i.Status,
		&i.CreatedAtSource,
		&i.UpdatedAtSource,
		&i.RawJson,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAppAssetBySourceAndKindAndExternalID = `-- name: GetAppAssetBySourceAndKindAndExternalID :one
SELECT id, source_kind, source_name, asset_kind, external_id, parent_external_id, display_name, status, created_at_source, updated_at_source, raw_json, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, created_at, updated_at
FROM app_assets
WHERE source_kind = $1::text
  AND source_name = $2::text
  AND asset_kind = $3::text
  AND external_id = $4::text
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

type GetAppAssetBySourceAndKindAndExternalIDParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	AssetKind  string `json:"asset_kind"`
	ExternalID string `json:"external_id"`
}

func (q *Queries) GetAppAssetBySourceAndKindAndExternalID(ctx context.Context, arg GetAppAssetBySourceAndKindAndExternalIDParams) (AppAsset, error) {
	row := q.db.QueryRow(ctx, getAppAssetBySourceAndKindAndExternalID,
		arg.SourceKind,
		arg.SourceName,
		arg.AssetKind,
		arg.ExternalID,
	)
	var i AppAsset
	err := row.Scan(
		&i.ID,
		&i.SourceKind,
		&i.SourceName,
		&i.AssetKind,
		&i.ExternalID,
		&i.ParentExternalID,
		&i.DisplayName,
		&i.Status,
		&i.CreatedAtSource,
		&i.UpdatedAtSource,
		&i.RawJson,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAppAssetsPageBySourceAndQueryAndKind = `-- name: ListAppAssetsPageBySourceAndQueryAndKind :many
SELECT aa.id, aa.source_kind, aa.source_name, aa.asset_kind, aa.external_id, aa.parent_external_id, aa.display_name, aa.status, aa.created_at_source, aa.updated_at_source, aa.raw_json, aa.seen_in_run_id, aa.seen_at, aa.last_observed_run_id, aa.last_observed_at, aa.expired_at, aa.expired_run_id, aa.created_at, aa.updated_at
FROM app_assets aa
WHERE
  aa.source_kind = $1::text
  AND aa.source_name = $2::text
  AND aa.expired_at IS NULL
  AND aa.last_observed_run_id IS NOT NULL
  AND (
    $3::text = ''
    OR aa.asset_kind = $3::text
  )
  AND (
    $4::text = ''
    OR aa.display_name ILIKE ('%' || $4::text || '%')
    OR aa.external_id ILIKE ('%' || $4::text || '%')
    OR aa.parent_external_id ILIKE ('%' || $4::text || '%')
  )
ORDER BY
  lower(COALESCE(NULLIF(trim(aa.display_name), ''), aa.external_id)) ASC,
  aa.id ASC
LIMIT $6::int
OFFSET $5::int
`

type ListAppAssetsPageBySourceAndQueryAndKindParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	AssetKind  string `json:"asset_kind"`
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

func (q *Queries) ListAppAssetsPageBySourceAndQueryAndKind(ctx context.Context, arg ListAppAssetsPageBySourceAndQueryAndKindParams) ([]AppAsset, error) {
	rows, err := q.db.Query(ctx, listAppAssetsPageBySourceAndQueryAndKind,
		arg.SourceKind,
		arg.SourceName,
		arg.AssetKind,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppAsset
	for rows.Next() {
		var i AppAsset
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.AssetKind,
			&i.ExternalID,
			&i.ParentExternalID,
			&i.DisplayName,
			&i.Status,
			&i.CreatedAtSource,
			&i.UpdatedAtSource,
			&i.RawJson,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const promoteAppAssetsSeenInRunBySource = `-- name: PromoteAppAssetsSeenInRunBySource :execrows
UPDATE app_assets
SET
  last_observed_run_id = $1::bigint,
  last_observed_at = now(),
  expired_at = NULL,
  expired_run_id = NULL
WHERE source_kind = $2::text
  AND source_name = $3::text
  AND seen_in_run_id = $1::bigint
`

type PromoteAppAssetsSeenInRunBySourceParams struct {
	LastObservedRunID int64  `json:"last_observed_run_id"`
	SourceKind        string `json:"source_kind"`
	SourceName        string `json:"source_name"`
}

func (q *Queries) PromoteAppAssetsSeenInRunBySource(ctx context.Context, arg PromoteAppAssetsSeenInRunBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, promoteAppAssetsSeenInRunBySource, arg.LastObservedRunID, arg.SourceKind, arg.SourceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertAppAssetsBulkBySource = `-- name: UpsertAppAssetsBulkBySource :execrows
WITH input AS (
  SELECT
    i,
    ($4::text[])[i] AS asset_kind,
    ($5::text[])[i] AS external_id,
    ($6::text[])[i] AS parent_external_id,
    ($7::text[])[i] AS display_name,
    ($8::text[])[i] AS status,
    ($9::timestamptz[])[i] AS created_at_source,
    ($10::timestamptz[])[i] AS updated_at_source,
    ($11::jsonb[])[i] AS raw_json
  FROM generate_subscripts($5::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (asset_kind, external_id)
    asset_kind,
    external_id,
    parent_external_id,
    display_name,
    status,
    created_at_source,
    updated_at_source,
    raw_json
  FROM input
  ORDER BY asset_kind, external_id, i DESC
)
INSERT INTO app_assets (
  source_kind,
  source_name,
  asset_kind,
  external_id,
  parent_external_id,
  display_name,
  status,
  created_at_source,
  updated_at_source,
  raw_json,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  $1::text,
  $2::text,
  input.asset_kind,
  input.external_id,
  input.parent_external_id,
  input.display_name,
  input.status,
  input.created_at_source,
  input.updated_at_source,
  input.raw_json,
  $3::bigint,
  now(),
  now()
FROM dedup input
ON CONFLICT (source_kind, source_name, asset_kind, external_id) DO UPDATE SET
  parent_external_id = EXCLUDED.parent_external_id,
  display_name = EXCLUDED.display_name,
  status = EXCLUDED.status,
  created_at_source = COALESCE(EXCLUDED.created_at_source, app_assets.created_at_source),
  updated_at_source = COALESCE(EXCLUDED.updated_at_source, app_assets.updated_at_source),
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertAppAssetsBulkBySourceParams struct {
	SourceKind        string               `json:"source_kind"`
	SourceName        string               `json:"source_name"`
	SeenInRunID       int64                `json:"seen_in_run_id"`
	AssetKinds        []string             `json:"asset_kinds"`
	ExternalIds       []string             `json:"external_ids"`
	ParentExternalIds []string             `json:"parent_external_ids"`
	DisplayNames      []string             `json:"display_names"`
	Statuses          []string             `json:"statuses"`
	CreatedAtSources  []pgtype.Timestamptz `json:"created_at_sources"`
	UpdatedAtSources  []pgtype.Timestamptz `json:"updated_at_sources"`
	RawJsons          [][]byte             `json:"raw_jsons"`
}

func (q *Queries) UpsertAppAssetsBulkBySource(ctx context.Context, arg UpsertAppAssetsBulkBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertAppAssetsBulkBySource,
		arg.SourceKind,
		arg.SourceName,
		arg.SeenInRunID,
		arg.AssetKinds,
		arg.ExternalIds,
		arg.ParentExternalIds,
		arg.DisplayNames,
		arg.Statuses,
		arg.CreatedAtSources,
		arg.UpdatedAtSources,
		arg.RawJsons,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

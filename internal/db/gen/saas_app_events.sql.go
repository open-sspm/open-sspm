// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: saas_app_events.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const expireSaaSAppEventsNotSeenInRunBySource = `-- name: ExpireSaaSAppEventsNotSeenInRunBySource :execrows
UPDATE saas_app_events
SET
  expired_at = now(),
  expired_run_id = $1::bigint
WHERE source_kind = $2::text
  AND source_name = $3::text
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND observed_at < now() - interval '30 days'
`

type ExpireSaaSAppEventsNotSeenInRunBySourceParams struct {
	ExpiredRunID int64  `json:"expired_run_id"`
	SourceKind   string `json:"source_kind"`
	SourceName   string `json:"source_name"`
}

func (q *Queries) ExpireSaaSAppEventsNotSeenInRunBySource(ctx context.Context, arg ExpireSaaSAppEventsNotSeenInRunBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, expireSaaSAppEventsNotSeenInRunBySource, arg.ExpiredRunID, arg.SourceKind, arg.SourceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getLatestSaaSDiscoveryObservedAtBySource = `-- name: GetLatestSaaSDiscoveryObservedAtBySource :one
SELECT max(observed_at)::timestamptz AS last_observed_at
FROM saas_app_events
WHERE source_kind = $1
  AND source_name = $2
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

type GetLatestSaaSDiscoveryObservedAtBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) GetLatestSaaSDiscoveryObservedAtBySource(ctx context.Context, arg GetLatestSaaSDiscoveryObservedAtBySourceParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getLatestSaaSDiscoveryObservedAtBySource, arg.SourceKind, arg.SourceName)
	var last_observed_at pgtype.Timestamptz
	err := row.Scan(&last_observed_at)
	return last_observed_at, err
}

const listSaaSAppEventsBySaaSAppID = `-- name: ListSaaSAppEventsBySaaSAppID :many
SELECT id, saas_app_id, source_kind, source_name, signal_kind, event_external_id, source_app_id, source_app_name, source_app_domain, actor_external_id, actor_email, actor_display_name, observed_at, scopes_json, raw_json, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, created_at, updated_at
FROM saas_app_events
WHERE saas_app_id = $1::bigint
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
ORDER BY observed_at DESC, id DESC
LIMIT $2::int
`

type ListSaaSAppEventsBySaaSAppIDParams struct {
	SaasAppID int64 `json:"saas_app_id"`
	LimitRows int32 `json:"limit_rows"`
}

func (q *Queries) ListSaaSAppEventsBySaaSAppID(ctx context.Context, arg ListSaaSAppEventsBySaaSAppIDParams) ([]SaasAppEvent, error) {
	rows, err := q.db.Query(ctx, listSaaSAppEventsBySaaSAppID, arg.SaasAppID, arg.LimitRows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SaasAppEvent
	for rows.Next() {
		var i SaasAppEvent
		if err := rows.Scan(
			&i.ID,
			&i.SaasAppID,
			&i.SourceKind,
			&i.SourceName,
			&i.SignalKind,
			&i.EventExternalID,
			&i.SourceAppID,
			&i.SourceAppName,
			&i.SourceAppDomain,
			&i.ActorExternalID,
			&i.ActorEmail,
			&i.ActorDisplayName,
			&i.ObservedAt,
			&i.ScopesJson,
			&i.RawJson,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSaaSAppIDsFromEventsSeenInRunBySource = `-- name: ListSaaSAppIDsFromEventsSeenInRunBySource :many
SELECT DISTINCT saas_app_id
FROM saas_app_events
WHERE source_kind = $1::text
  AND source_name = $2::text
  AND seen_in_run_id = $3::bigint
ORDER BY saas_app_id ASC
`

type ListSaaSAppIDsFromEventsSeenInRunBySourceParams struct {
	SourceKind  string `json:"source_kind"`
	SourceName  string `json:"source_name"`
	SeenInRunID int64  `json:"seen_in_run_id"`
}

func (q *Queries) ListSaaSAppIDsFromEventsSeenInRunBySource(ctx context.Context, arg ListSaaSAppIDsFromEventsSeenInRunBySourceParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, listSaaSAppIDsFromEventsSeenInRunBySource, arg.SourceKind, arg.SourceName, arg.SeenInRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var saas_app_id int64
		if err := rows.Scan(&saas_app_id); err != nil {
			return nil, err
		}
		items = append(items, saas_app_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopActorsForSaaSAppByID = `-- name: ListTopActorsForSaaSAppByID :many
SELECT
  COALESCE(NULLIF(trim(actor_display_name), ''), NULLIF(trim(actor_email), ''), NULLIF(trim(actor_external_id), ''), '')::text AS actor_label,
  COALESCE(NULLIF(trim(actor_email), ''), '')::text AS actor_email,
  COALESCE(NULLIF(trim(actor_external_id), ''), '')::text AS actor_external_id,
  count(*) AS event_count,
  max(observed_at)::timestamptz AS last_observed_at
FROM saas_app_events
WHERE saas_app_id = $1::bigint
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND observed_at >= now() - interval '30 days'
GROUP BY actor_label, actor_email, actor_external_id
ORDER BY event_count DESC, last_observed_at DESC
LIMIT $2::int
`

type ListTopActorsForSaaSAppByIDParams struct {
	SaasAppID int64 `json:"saas_app_id"`
	LimitRows int32 `json:"limit_rows"`
}

type ListTopActorsForSaaSAppByIDRow struct {
	ActorLabel      string             `json:"actor_label"`
	ActorEmail      string             `json:"actor_email"`
	ActorExternalID string             `json:"actor_external_id"`
	EventCount      int64              `json:"event_count"`
	LastObservedAt  pgtype.Timestamptz `json:"last_observed_at"`
}

func (q *Queries) ListTopActorsForSaaSAppByID(ctx context.Context, arg ListTopActorsForSaaSAppByIDParams) ([]ListTopActorsForSaaSAppByIDRow, error) {
	rows, err := q.db.Query(ctx, listTopActorsForSaaSAppByID, arg.SaasAppID, arg.LimitRows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTopActorsForSaaSAppByIDRow
	for rows.Next() {
		var i ListTopActorsForSaaSAppByIDRow
		if err := rows.Scan(
			&i.ActorLabel,
			&i.ActorEmail,
			&i.ActorExternalID,
			&i.EventCount,
			&i.LastObservedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const promoteSaaSAppEventsSeenInRunBySource = `-- name: PromoteSaaSAppEventsSeenInRunBySource :execrows
UPDATE saas_app_events
SET
  last_observed_run_id = $1::bigint,
  last_observed_at = now(),
  expired_at = NULL,
  expired_run_id = NULL
WHERE source_kind = $2::text
  AND source_name = $3::text
  AND seen_in_run_id = $1::bigint
`

type PromoteSaaSAppEventsSeenInRunBySourceParams struct {
	LastObservedRunID int64  `json:"last_observed_run_id"`
	SourceKind        string `json:"source_kind"`
	SourceName        string `json:"source_name"`
}

func (q *Queries) PromoteSaaSAppEventsSeenInRunBySource(ctx context.Context, arg PromoteSaaSAppEventsSeenInRunBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, promoteSaaSAppEventsSeenInRunBySource, arg.LastObservedRunID, arg.SourceKind, arg.SourceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertSaaSAppEventsBulkBySource = `-- name: UpsertSaaSAppEventsBulkBySource :execrows
WITH input AS (
  SELECT
    i,
    $2::text AS source_kind,
    $3::text AS source_name,
    ($4::text[])[i] AS canonical_key,
    ($5::text[])[i] AS signal_kind,
    ($6::text[])[i] AS event_external_id,
    ($7::text[])[i] AS source_app_id,
    ($8::text[])[i] AS source_app_name,
    ($9::text[])[i] AS source_app_domain,
    ($10::text[])[i] AS actor_external_id,
    ($11::text[])[i] AS actor_email,
    ($12::text[])[i] AS actor_display_name,
    ($13::timestamptz[])[i] AS observed_at,
    ($14::jsonb[])[i] AS scopes_json,
    ($15::jsonb[])[i] AS raw_json
  FROM generate_subscripts($6::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (source_kind, source_name, signal_kind, event_external_id)
    source_kind,
    source_name,
    canonical_key,
    signal_kind,
    event_external_id,
    source_app_id,
    source_app_name,
    source_app_domain,
    actor_external_id,
    actor_email,
    actor_display_name,
    observed_at,
    scopes_json,
    raw_json
  FROM input
  WHERE trim(event_external_id) <> ''
  ORDER BY source_kind, source_name, signal_kind, event_external_id, i DESC
)
INSERT INTO saas_app_events (
  saas_app_id,
  source_kind,
  source_name,
  signal_kind,
  event_external_id,
  source_app_id,
  source_app_name,
  source_app_domain,
  actor_external_id,
  actor_email,
  actor_display_name,
  observed_at,
  scopes_json,
  raw_json,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  sa.id,
  d.source_kind,
  d.source_name,
  d.signal_kind,
  d.event_external_id,
  d.source_app_id,
  d.source_app_name,
  d.source_app_domain,
  d.actor_external_id,
  lower(trim(d.actor_email)),
  d.actor_display_name,
  d.observed_at,
  COALESCE(d.scopes_json, '[]'::jsonb),
  COALESCE(d.raw_json, '{}'::jsonb),
  $1::bigint,
  now(),
  now()
FROM dedup d
JOIN saas_apps sa ON sa.canonical_key = d.canonical_key
ON CONFLICT (source_kind, source_name, signal_kind, event_external_id) DO UPDATE SET
  saas_app_id = EXCLUDED.saas_app_id,
  source_app_id = EXCLUDED.source_app_id,
  source_app_name = EXCLUDED.source_app_name,
  source_app_domain = EXCLUDED.source_app_domain,
  actor_external_id = EXCLUDED.actor_external_id,
  actor_email = EXCLUDED.actor_email,
  actor_display_name = EXCLUDED.actor_display_name,
  observed_at = EXCLUDED.observed_at,
  scopes_json = EXCLUDED.scopes_json,
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertSaaSAppEventsBulkBySourceParams struct {
	SeenInRunID       int64                `json:"seen_in_run_id"`
	SourceKind        string               `json:"source_kind"`
	SourceName        string               `json:"source_name"`
	CanonicalKeys     []string             `json:"canonical_keys"`
	SignalKinds       []string             `json:"signal_kinds"`
	EventExternalIds  []string             `json:"event_external_ids"`
	SourceAppIds      []string             `json:"source_app_ids"`
	SourceAppNames    []string             `json:"source_app_names"`
	SourceAppDomains  []string             `json:"source_app_domains"`
	ActorExternalIds  []string             `json:"actor_external_ids"`
	ActorEmails       []string             `json:"actor_emails"`
	ActorDisplayNames []string             `json:"actor_display_names"`
	ObservedAts       []pgtype.Timestamptz `json:"observed_ats"`
	ScopesJsons       [][]byte             `json:"scopes_jsons"`
	RawJsons          [][]byte             `json:"raw_jsons"`
}

func (q *Queries) UpsertSaaSAppEventsBulkBySource(ctx context.Context, arg UpsertSaaSAppEventsBulkBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertSaaSAppEventsBulkBySource,
		arg.SeenInRunID,
		arg.SourceKind,
		arg.SourceName,
		arg.CanonicalKeys,
		arg.SignalKinds,
		arg.EventExternalIds,
		arg.SourceAppIds,
		arg.SourceAppNames,
		arg.SourceAppDomains,
		arg.ActorExternalIds,
		arg.ActorEmails,
		arg.ActorDisplayNames,
		arg.ObservedAts,
		arg.ScopesJsons,
		arg.RawJsons,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

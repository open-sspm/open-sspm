// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: google_workspace.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countGoogleWorkspaceGroupsBySourceAndQuery = `-- name: CountGoogleWorkspaceGroupsBySourceAndQuery :one
SELECT count(*)
FROM accounts au
WHERE
  au.source_kind = $1::text
  AND au.source_name = $2::text
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND lower(COALESCE(NULLIF(trim(au.raw_json ->> 'entity_category'), ''), '')) = 'group'
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
`

type CountGoogleWorkspaceGroupsBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
}

func (q *Queries) CountGoogleWorkspaceGroupsBySourceAndQuery(ctx context.Context, arg CountGoogleWorkspaceGroupsBySourceAndQueryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countGoogleWorkspaceGroupsBySourceAndQuery, arg.SourceKind, arg.SourceName, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGoogleWorkspaceUsersBySourceAndQuery = `-- name: CountGoogleWorkspaceUsersBySourceAndQuery :one
SELECT count(*)
FROM accounts au
WHERE
  au.source_kind = $1::text
  AND au.source_name = $2::text
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND lower(COALESCE(NULLIF(trim(au.raw_json ->> 'entity_category'), ''), '')) = 'user'
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
`

type CountGoogleWorkspaceUsersBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
}

func (q *Queries) CountGoogleWorkspaceUsersBySourceAndQuery(ctx context.Context, arg CountGoogleWorkspaceUsersBySourceAndQueryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countGoogleWorkspaceUsersBySourceAndQuery, arg.SourceKind, arg.SourceName, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnmatchedGoogleWorkspaceUsersBySourceAndQuery = `-- name: CountUnmatchedGoogleWorkspaceUsersBySourceAndQuery :one
WITH authoritative_identities AS (
  SELECT DISTINCT ia.identity_id
  FROM identity_accounts ia
  JOIN accounts anchor ON anchor.id = ia.account_id
  JOIN identity_source_settings iss
    ON iss.source_kind = anchor.source_kind
   AND iss.source_name = anchor.source_name
   AND iss.is_authoritative
  WHERE anchor.expired_at IS NULL
    AND anchor.last_observed_run_id IS NOT NULL
)
SELECT count(*)
FROM accounts au
WHERE
  au.source_kind = $1::text
  AND au.source_name = $2::text
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND lower(COALESCE(NULLIF(trim(au.raw_json ->> 'entity_category'), ''), '')) = 'user'
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
  AND NOT EXISTS (
    SELECT 1
    FROM identity_accounts ia
    WHERE ia.account_id = au.id
      AND ia.identity_id IN (SELECT identity_id FROM authoritative_identities)
  )
`

type CountUnmatchedGoogleWorkspaceUsersBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
}

func (q *Queries) CountUnmatchedGoogleWorkspaceUsersBySourceAndQuery(ctx context.Context, arg CountUnmatchedGoogleWorkspaceUsersBySourceAndQueryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUnmatchedGoogleWorkspaceUsersBySourceAndQuery, arg.SourceKind, arg.SourceName, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listGoogleWorkspaceGroupMemberCountsByGroupExternalIDs = `-- name: ListGoogleWorkspaceGroupMemberCountsByGroupExternalIDs :many
WITH requested AS (
  SELECT DISTINCT trim(group_external_id)::text AS group_external_id
  FROM unnest($1::text[]) AS g(group_external_id)
  WHERE trim(group_external_id) <> ''
)
SELECT
  requested.group_external_id,
  count(DISTINCT e.app_user_id)::bigint AS member_count,
  count(DISTINCT e.app_user_id) FILTER (WHERE lower(trim(e.permission)) = 'owner')::bigint AS owner_count,
  count(DISTINCT e.app_user_id) FILTER (WHERE lower(trim(e.permission)) = 'manager')::bigint AS manager_count
FROM requested
LEFT JOIN entitlements e
  ON e.kind = 'google_group_member'
 AND e.resource = ('google_group:' || requested.group_external_id)
 AND e.expired_at IS NULL
 AND e.last_observed_run_id IS NOT NULL
GROUP BY requested.group_external_id
ORDER BY requested.group_external_id
`

type ListGoogleWorkspaceGroupMemberCountsByGroupExternalIDsRow struct {
	GroupExternalID string `json:"group_external_id"`
	MemberCount     int64  `json:"member_count"`
	OwnerCount      int64  `json:"owner_count"`
	ManagerCount    int64  `json:"manager_count"`
}

func (q *Queries) ListGoogleWorkspaceGroupMemberCountsByGroupExternalIDs(ctx context.Context, groupExternalIds []string) ([]ListGoogleWorkspaceGroupMemberCountsByGroupExternalIDsRow, error) {
	rows, err := q.db.Query(ctx, listGoogleWorkspaceGroupMemberCountsByGroupExternalIDs, groupExternalIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGoogleWorkspaceGroupMemberCountsByGroupExternalIDsRow
	for rows.Next() {
		var i ListGoogleWorkspaceGroupMemberCountsByGroupExternalIDsRow
		if err := rows.Scan(
			&i.GroupExternalID,
			&i.MemberCount,
			&i.OwnerCount,
			&i.ManagerCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGoogleWorkspaceGroupsPageBySourceAndQuery = `-- name: ListGoogleWorkspaceGroupsPageBySourceAndQuery :many
SELECT au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id, au.status, au.account_kind
FROM accounts au
WHERE
  au.source_kind = $1::text
  AND au.source_name = $2::text
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND lower(COALESCE(NULLIF(trim(au.raw_json ->> 'entity_category'), ''), '')) = 'group'
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
ORDER BY lower(COALESCE(NULLIF(trim(au.display_name), ''), au.external_id)) ASC, au.id ASC
LIMIT $5::int
OFFSET $4::int
`

type ListGoogleWorkspaceGroupsPageBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

func (q *Queries) ListGoogleWorkspaceGroupsPageBySourceAndQuery(ctx context.Context, arg ListGoogleWorkspaceGroupsPageBySourceAndQueryParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listGoogleWorkspaceGroupsPageBySourceAndQuery,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
			&i.AccountKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGoogleWorkspaceUsersPageBySourceAndQuery = `-- name: ListGoogleWorkspaceUsersPageBySourceAndQuery :many
SELECT
  au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id, au.status, au.account_kind,
  COALESCE(ia.identity_id, 0) AS idp_user_id
FROM accounts au
LEFT JOIN identity_accounts ia ON ia.account_id = au.id
WHERE
  au.source_kind = $1::text
  AND au.source_name = $2::text
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND lower(COALESCE(NULLIF(trim(au.raw_json ->> 'entity_category'), ''), '')) = 'user'
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
ORDER BY au.id DESC
LIMIT $5::int
OFFSET $4::int
`

type ListGoogleWorkspaceUsersPageBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

type ListGoogleWorkspaceUsersPageBySourceAndQueryRow struct {
	ID                int64              `json:"id"`
	SourceKind        string             `json:"source_kind"`
	SourceName        string             `json:"source_name"`
	ExternalID        string             `json:"external_id"`
	Email             string             `json:"email"`
	DisplayName       string             `json:"display_name"`
	RawJson           []byte             `json:"raw_json"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	LastLoginAt       pgtype.Timestamptz `json:"last_login_at"`
	LastLoginIp       string             `json:"last_login_ip"`
	LastLoginRegion   string             `json:"last_login_region"`
	SeenInRunID       pgtype.Int8        `json:"seen_in_run_id"`
	SeenAt            pgtype.Timestamptz `json:"seen_at"`
	LastObservedRunID pgtype.Int8        `json:"last_observed_run_id"`
	LastObservedAt    pgtype.Timestamptz `json:"last_observed_at"`
	ExpiredAt         pgtype.Timestamptz `json:"expired_at"`
	ExpiredRunID      pgtype.Int8        `json:"expired_run_id"`
	Status            string             `json:"status"`
	AccountKind       string             `json:"account_kind"`
	IdpUserID         int64              `json:"idp_user_id"`
}

func (q *Queries) ListGoogleWorkspaceUsersPageBySourceAndQuery(ctx context.Context, arg ListGoogleWorkspaceUsersPageBySourceAndQueryParams) ([]ListGoogleWorkspaceUsersPageBySourceAndQueryRow, error) {
	rows, err := q.db.Query(ctx, listGoogleWorkspaceUsersPageBySourceAndQuery,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGoogleWorkspaceUsersPageBySourceAndQueryRow
	for rows.Next() {
		var i ListGoogleWorkspaceUsersPageBySourceAndQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
			&i.AccountKind,
			&i.IdpUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedGoogleWorkspaceUsersPageBySourceAndQuery = `-- name: ListUnmatchedGoogleWorkspaceUsersPageBySourceAndQuery :many
WITH authoritative_identities AS (
  SELECT DISTINCT ia.identity_id
  FROM identity_accounts ia
  JOIN accounts anchor ON anchor.id = ia.account_id
  JOIN identity_source_settings iss
    ON iss.source_kind = anchor.source_kind
   AND iss.source_name = anchor.source_name
   AND iss.is_authoritative
  WHERE anchor.expired_at IS NULL
    AND anchor.last_observed_run_id IS NOT NULL
)
SELECT au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id, au.status, au.account_kind
FROM accounts au
WHERE
  au.source_kind = $1::text
  AND au.source_name = $2::text
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND lower(COALESCE(NULLIF(trim(au.raw_json ->> 'entity_category'), ''), '')) = 'user'
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
  AND NOT EXISTS (
    SELECT 1
    FROM identity_accounts ia
    WHERE ia.account_id = au.id
      AND ia.identity_id IN (SELECT identity_id FROM authoritative_identities)
  )
ORDER BY au.id DESC
LIMIT $5::int
OFFSET $4::int
`

type ListUnmatchedGoogleWorkspaceUsersPageBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

func (q *Queries) ListUnmatchedGoogleWorkspaceUsersPageBySourceAndQuery(ctx context.Context, arg ListUnmatchedGoogleWorkspaceUsersPageBySourceAndQueryParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listUnmatchedGoogleWorkspaceUsersPageBySourceAndQuery,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
			&i.AccountKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: saas_app_bindings.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearPrimarySaaSAppBindingsBySaaSAppID = `-- name: ClearPrimarySaaSAppBindingsBySaaSAppID :exec
UPDATE saas_app_bindings
SET is_primary = false,
    updated_at = now()
WHERE saas_app_id = $1::bigint
  AND is_primary
`

func (q *Queries) ClearPrimarySaaSAppBindingsBySaaSAppID(ctx context.Context, saasAppID int64) error {
	_, err := q.db.Exec(ctx, clearPrimarySaaSAppBindingsBySaaSAppID, saasAppID)
	return err
}

const deleteManualSaaSAppBindingsBySaaSAppID = `-- name: DeleteManualSaaSAppBindingsBySaaSAppID :execrows
DELETE FROM saas_app_bindings
WHERE saas_app_id = $1::bigint
  AND binding_source = 'manual'
`

func (q *Queries) DeleteManualSaaSAppBindingsBySaaSAppID(ctx context.Context, saasAppID int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteManualSaaSAppBindingsBySaaSAppID, saasAppID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listSaaSAppBindingsBySaaSAppID = `-- name: ListSaaSAppBindingsBySaaSAppID :many
SELECT id, saas_app_id, connector_kind, connector_source_name, binding_source, confidence, is_primary, created_by_auth_user_id, created_at, updated_at
FROM saas_app_bindings
WHERE saas_app_id = $1
ORDER BY
  is_primary DESC,
  CASE WHEN binding_source = 'manual' THEN 0 ELSE 1 END,
  confidence DESC,
  id ASC
`

func (q *Queries) ListSaaSAppBindingsBySaaSAppID(ctx context.Context, saasAppID int64) ([]SaasAppBinding, error) {
	rows, err := q.db.Query(ctx, listSaaSAppBindingsBySaaSAppID, saasAppID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SaasAppBinding
	for rows.Next() {
		var i SaasAppBinding
		if err := rows.Scan(
			&i.ID,
			&i.SaasAppID,
			&i.ConnectorKind,
			&i.ConnectorSourceName,
			&i.BindingSource,
			&i.Confidence,
			&i.IsPrimary,
			&i.CreatedByAuthUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recomputePrimarySaaSAppBindingBySaaSAppID = `-- name: RecomputePrimarySaaSAppBindingBySaaSAppID :execrows
WITH ranked AS (
  SELECT
    id,
    row_number() OVER (
      ORDER BY
        CASE WHEN binding_source = 'manual' THEN 0 ELSE 1 END,
        confidence DESC,
        id ASC
    ) AS rn
  FROM saas_app_bindings
  WHERE saas_app_id = $1::bigint
)
UPDATE saas_app_bindings b
SET
  is_primary = (r.rn = 1),
  updated_at = now()
FROM ranked r
WHERE b.id = r.id
  AND b.is_primary IS DISTINCT FROM (r.rn = 1)
`

func (q *Queries) RecomputePrimarySaaSAppBindingBySaaSAppID(ctx context.Context, saasAppID int64) (int64, error) {
	result, err := q.db.Exec(ctx, recomputePrimarySaaSAppBindingBySaaSAppID, saasAppID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const recomputePrimarySaaSAppBindingsForAll = `-- name: RecomputePrimarySaaSAppBindingsForAll :execrows
WITH ranked AS (
  SELECT
    id,
    saas_app_id,
    row_number() OVER (
      PARTITION BY saas_app_id
      ORDER BY
        CASE WHEN binding_source = 'manual' THEN 0 ELSE 1 END,
        confidence DESC,
        id ASC
    ) AS rn
  FROM saas_app_bindings
)
UPDATE saas_app_bindings b
SET
  is_primary = (r.rn = 1),
  updated_at = now()
FROM ranked r
WHERE b.id = r.id
  AND b.is_primary IS DISTINCT FROM (r.rn = 1)
`

func (q *Queries) RecomputePrimarySaaSAppBindingsForAll(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, recomputePrimarySaaSAppBindingsForAll)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertSaaSAppBinding = `-- name: UpsertSaaSAppBinding :exec
INSERT INTO saas_app_bindings (
  saas_app_id,
  connector_kind,
  connector_source_name,
  binding_source,
  confidence,
  is_primary,
  created_by_auth_user_id,
  updated_at
)
VALUES (
  $1::bigint,
  $2::text,
  $3::text,
  $4::text,
  $5::real,
  $6::boolean,
  $7::bigint,
  now()
)
ON CONFLICT (saas_app_id, connector_kind, connector_source_name) DO UPDATE SET
  binding_source = EXCLUDED.binding_source,
  confidence = EXCLUDED.confidence,
  is_primary = EXCLUDED.is_primary,
  created_by_auth_user_id = COALESCE(EXCLUDED.created_by_auth_user_id, saas_app_bindings.created_by_auth_user_id),
  updated_at = now()
WHERE NOT (
  saas_app_bindings.binding_source = 'manual'
  AND EXCLUDED.binding_source = 'auto'
)
`

type UpsertSaaSAppBindingParams struct {
	SaasAppID           int64       `json:"saas_app_id"`
	ConnectorKind       string      `json:"connector_kind"`
	ConnectorSourceName string      `json:"connector_source_name"`
	BindingSource       string      `json:"binding_source"`
	Confidence          float32     `json:"confidence"`
	IsPrimary           bool        `json:"is_primary"`
	CreatedByAuthUserID pgtype.Int8 `json:"created_by_auth_user_id"`
}

func (q *Queries) UpsertSaaSAppBinding(ctx context.Context, arg UpsertSaaSAppBindingParams) error {
	_, err := q.db.Exec(ctx, upsertSaaSAppBinding,
		arg.SaasAppID,
		arg.ConnectorKind,
		arg.ConnectorSourceName,
		arg.BindingSource,
		arg.Confidence,
		arg.IsPrimary,
		arg.CreatedByAuthUserID,
	)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: identity_source_settings.sql

package gen

import (
	"context"
)

const getIdentitySourceSetting = `-- name: GetIdentitySourceSetting :one
SELECT source_kind, source_name, is_authoritative, created_at, updated_at
FROM identity_source_settings
WHERE source_kind = $1
  AND source_name = $2
`

type GetIdentitySourceSettingParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) GetIdentitySourceSetting(ctx context.Context, arg GetIdentitySourceSettingParams) (IdentitySourceSetting, error) {
	row := q.db.QueryRow(ctx, getIdentitySourceSetting, arg.SourceKind, arg.SourceName)
	var i IdentitySourceSetting
	err := row.Scan(
		&i.SourceKind,
		&i.SourceName,
		&i.IsAuthoritative,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAuthoritativeSources = `-- name: ListAuthoritativeSources :many
SELECT source_kind, source_name, is_authoritative, created_at, updated_at
FROM identity_source_settings
WHERE is_authoritative = TRUE
ORDER BY source_kind, source_name
`

func (q *Queries) ListAuthoritativeSources(ctx context.Context) ([]IdentitySourceSetting, error) {
	rows, err := q.db.Query(ctx, listAuthoritativeSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IdentitySourceSetting
	for rows.Next() {
		var i IdentitySourceSetting
		if err := rows.Scan(
			&i.SourceKind,
			&i.SourceName,
			&i.IsAuthoritative,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIdentitySourceSettings = `-- name: ListIdentitySourceSettings :many
SELECT source_kind, source_name, is_authoritative, created_at, updated_at
FROM identity_source_settings
ORDER BY source_kind, source_name
`

func (q *Queries) ListIdentitySourceSettings(ctx context.Context) ([]IdentitySourceSetting, error) {
	rows, err := q.db.Query(ctx, listIdentitySourceSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IdentitySourceSetting
	for rows.Next() {
		var i IdentitySourceSetting
		if err := rows.Scan(
			&i.SourceKind,
			&i.SourceName,
			&i.IsAuthoritative,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertIdentitySourceSetting = `-- name: UpsertIdentitySourceSetting :one
INSERT INTO identity_source_settings (source_kind, source_name, is_authoritative, updated_at)
VALUES (
  $1::text,
  $2::text,
  $3::boolean,
  now()
)
ON CONFLICT (source_kind, source_name) DO UPDATE SET
  is_authoritative = EXCLUDED.is_authoritative,
  updated_at = EXCLUDED.updated_at
RETURNING source_kind, source_name, is_authoritative, created_at, updated_at
`

type UpsertIdentitySourceSettingParams struct {
	SourceKind      string `json:"source_kind"`
	SourceName      string `json:"source_name"`
	IsAuthoritative bool   `json:"is_authoritative"`
}

func (q *Queries) UpsertIdentitySourceSetting(ctx context.Context, arg UpsertIdentitySourceSettingParams) (IdentitySourceSetting, error) {
	row := q.db.QueryRow(ctx, upsertIdentitySourceSetting, arg.SourceKind, arg.SourceName, arg.IsAuthoritative)
	var i IdentitySourceSetting
	err := row.Scan(
		&i.SourceKind,
		&i.SourceName,
		&i.IsAuthoritative,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

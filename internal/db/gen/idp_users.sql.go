// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: idp_users.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countIdPUsers = `-- name: CountIdPUsers :one
SELECT count(*)
FROM idp_users
WHERE expired_at IS NULL AND last_observed_run_id IS NOT NULL
`

func (q *Queries) CountIdPUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countIdPUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIdPUsersByQueryAndState = `-- name: CountIdPUsersByQueryAndState :one
SELECT count(*)
FROM idp_users
WHERE
  expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND (
    $1::text = ''
    OR email ILIKE ('%' || $1::text || '%')
    OR display_name ILIKE ('%' || $1::text || '%')
    OR external_id ILIKE ('%' || $1::text || '%')
  )
  AND (
    $2::text = ''
    OR ($2::text = 'active' AND status = 'ACTIVE')
    OR ($2::text = 'inactive' AND status <> 'ACTIVE')
  )
`

type CountIdPUsersByQueryAndStateParams struct {
	Query string `json:"query"`
	State string `json:"state"`
}

func (q *Queries) CountIdPUsersByQueryAndState(ctx context.Context, arg CountIdPUsersByQueryAndStateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countIdPUsersByQueryAndState, arg.Query, arg.State)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const findIdPUserByEmail = `-- name: FindIdPUserByEmail :one
SELECT id, external_id, email, display_name, status, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
FROM idp_users
WHERE email = $1 AND expired_at IS NULL AND last_observed_run_id IS NOT NULL
LIMIT 1
`

func (q *Queries) FindIdPUserByEmail(ctx context.Context, email string) (IdpUser, error) {
	row := q.db.QueryRow(ctx, findIdPUserByEmail, email)
	var i IdpUser
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Email,
		&i.DisplayName,
		&i.Status,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.LastLoginRegion,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
	)
	return i, err
}

const getIdPUser = `-- name: GetIdPUser :one
SELECT id, external_id, email, display_name, status, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
FROM idp_users
WHERE id = $1 AND expired_at IS NULL AND last_observed_run_id IS NOT NULL
`

func (q *Queries) GetIdPUser(ctx context.Context, id int64) (IdpUser, error) {
	row := q.db.QueryRow(ctx, getIdPUser, id)
	var i IdpUser
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Email,
		&i.DisplayName,
		&i.Status,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.LastLoginRegion,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
	)
	return i, err
}

const listIdPUsers = `-- name: ListIdPUsers :many
SELECT id, external_id, email, display_name, status, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
FROM idp_users
WHERE expired_at IS NULL AND last_observed_run_id IS NOT NULL
ORDER BY id ASC
`

func (q *Queries) ListIdPUsers(ctx context.Context) ([]IdpUser, error) {
	rows, err := q.db.Query(ctx, listIdPUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IdpUser
	for rows.Next() {
		var i IdpUser
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.Status,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIdPUsersByStatus = `-- name: ListIdPUsersByStatus :many
SELECT id, external_id, email, display_name, status, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
FROM idp_users
WHERE
  expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND (
  (COALESCE($1::text, '') = '')
  OR ($1::text = 'active' AND status = 'ACTIVE')
  OR ($1::text = 'inactive' AND status <> 'ACTIVE')
  )
ORDER BY id ASC
`

func (q *Queries) ListIdPUsersByStatus(ctx context.Context, dollar_1 string) ([]IdpUser, error) {
	rows, err := q.db.Query(ctx, listIdPUsersByStatus, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IdpUser
	for rows.Next() {
		var i IdpUser
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.Status,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIdPUsersForCommand = `-- name: ListIdPUsersForCommand :many
SELECT
  id,
  email,
  display_name,
  status
FROM idp_users
WHERE expired_at IS NULL AND last_observed_run_id IS NOT NULL
ORDER BY
  (status = 'ACTIVE') DESC,
  lower(COALESCE(NULLIF(trim(display_name), ''), email)) ASC,
  lower(email) ASC,
  id ASC
`

type ListIdPUsersForCommandRow struct {
	ID          int64  `json:"id"`
	Email       string `json:"email"`
	DisplayName string `json:"display_name"`
	Status      string `json:"status"`
}

func (q *Queries) ListIdPUsersForCommand(ctx context.Context) ([]ListIdPUsersForCommandRow, error) {
	rows, err := q.db.Query(ctx, listIdPUsersForCommand)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIdPUsersForCommandRow
	for rows.Next() {
		var i ListIdPUsersForCommandRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.DisplayName,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIdPUsersPageByQueryAndState = `-- name: ListIdPUsersPageByQueryAndState :many
SELECT id, external_id, email, display_name, status, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
FROM idp_users
WHERE
  expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND (
    $1::text = ''
    OR email ILIKE ('%' || $1::text || '%')
    OR display_name ILIKE ('%' || $1::text || '%')
    OR external_id ILIKE ('%' || $1::text || '%')
  )
  AND (
    $2::text = ''
    OR ($2::text = 'active' AND status = 'ACTIVE')
    OR ($2::text = 'inactive' AND status <> 'ACTIVE')
  )
ORDER BY id ASC
LIMIT $4::int
OFFSET $3::int
`

type ListIdPUsersPageByQueryAndStateParams struct {
	Query      string `json:"query"`
	State      string `json:"state"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

func (q *Queries) ListIdPUsersPageByQueryAndState(ctx context.Context, arg ListIdPUsersPageByQueryAndStateParams) ([]IdpUser, error) {
	rows, err := q.db.Query(ctx, listIdPUsersPageByQueryAndState,
		arg.Query,
		arg.State,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IdpUser
	for rows.Next() {
		var i IdpUser
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.Status,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertIdPUser = `-- name: UpsertIdPUser :one
INSERT INTO idp_users (external_id, email, display_name, status, raw_json, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, updated_at)
VALUES (
  $1::text,
  lower(trim($2::text)),
  $3::text,
  $4::text,
  $5::jsonb,
  $6::timestamptz,
  $7::text,
  $8::text,
  $9::bigint,
  now(),
  now()
)
ON CONFLICT (external_id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name,
  status = EXCLUDED.status,
  raw_json = EXCLUDED.raw_json,
  last_login_at = COALESCE(EXCLUDED.last_login_at, idp_users.last_login_at),
  last_login_ip = CASE WHEN EXCLUDED.last_login_ip <> '' THEN EXCLUDED.last_login_ip ELSE idp_users.last_login_ip END,
  last_login_region = CASE WHEN EXCLUDED.last_login_region <> '' THEN EXCLUDED.last_login_region ELSE idp_users.last_login_region END,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
RETURNING id, external_id, email, display_name, status, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
`

type UpsertIdPUserParams struct {
	ExternalID      string             `json:"external_id"`
	Email           string             `json:"email"`
	DisplayName     string             `json:"display_name"`
	Status          string             `json:"status"`
	RawJson         []byte             `json:"raw_json"`
	LastLoginAt     pgtype.Timestamptz `json:"last_login_at"`
	LastLoginIp     string             `json:"last_login_ip"`
	LastLoginRegion string             `json:"last_login_region"`
	SeenInRunID     int64              `json:"seen_in_run_id"`
}

func (q *Queries) UpsertIdPUser(ctx context.Context, arg UpsertIdPUserParams) (IdpUser, error) {
	row := q.db.QueryRow(ctx, upsertIdPUser,
		arg.ExternalID,
		arg.Email,
		arg.DisplayName,
		arg.Status,
		arg.RawJson,
		arg.LastLoginAt,
		arg.LastLoginIp,
		arg.LastLoginRegion,
		arg.SeenInRunID,
	)
	var i IdpUser
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Email,
		&i.DisplayName,
		&i.Status,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.LastLoginRegion,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
	)
	return i, err
}

const upsertIdPUsersBulk = `-- name: UpsertIdPUsersBulk :execrows
WITH input AS (
  SELECT
    i,
    ($2::text[])[i] AS external_id,
    lower(trim(($3::text[])[i])) AS email,
    ($4::text[])[i] AS display_name,
    ($5::text[])[i] AS status,
    ($6::jsonb[])[i] AS raw_json,
    ($7::timestamptz[])[i] AS last_login_at,
    ($8::text[])[i] AS last_login_ip,
    ($9::text[])[i] AS last_login_region
  FROM generate_subscripts($2::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (external_id)
    external_id,
    email,
    display_name,
    status,
    raw_json,
    last_login_at,
    last_login_ip,
    last_login_region
  FROM input
  ORDER BY external_id, i DESC
)
INSERT INTO idp_users (
  external_id,
  email,
  display_name,
  status,
  raw_json,
  last_login_at,
  last_login_ip,
  last_login_region,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  input.external_id,
  input.email,
  input.display_name,
  input.status,
  input.raw_json,
  input.last_login_at,
  input.last_login_ip,
  input.last_login_region,
  $1::bigint,
  now(),
  now()
FROM dedup input
ON CONFLICT (external_id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name,
  status = EXCLUDED.status,
  raw_json = EXCLUDED.raw_json,
  last_login_at = COALESCE(EXCLUDED.last_login_at, idp_users.last_login_at),
  last_login_ip = CASE WHEN EXCLUDED.last_login_ip <> '' THEN EXCLUDED.last_login_ip ELSE idp_users.last_login_ip END,
  last_login_region = CASE WHEN EXCLUDED.last_login_region <> '' THEN EXCLUDED.last_login_region ELSE idp_users.last_login_region END,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertIdPUsersBulkParams struct {
	SeenInRunID      int64                `json:"seen_in_run_id"`
	ExternalIds      []string             `json:"external_ids"`
	Emails           []string             `json:"emails"`
	DisplayNames     []string             `json:"display_names"`
	Statuses         []string             `json:"statuses"`
	RawJsons         [][]byte             `json:"raw_jsons"`
	LastLoginAts     []pgtype.Timestamptz `json:"last_login_ats"`
	LastLoginIps     []string             `json:"last_login_ips"`
	LastLoginRegions []string             `json:"last_login_regions"`
}

func (q *Queries) UpsertIdPUsersBulk(ctx context.Context, arg UpsertIdPUsersBulkParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertIdPUsersBulk,
		arg.SeenInRunID,
		arg.ExternalIds,
		arg.Emails,
		arg.DisplayNames,
		arg.Statuses,
		arg.RawJsons,
		arg.LastLoginAts,
		arg.LastLoginIps,
		arg.LastLoginRegions,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: idp_users.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countIdPUsers = `-- name: CountIdPUsers :one
SELECT count(*)
FROM accounts
WHERE source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

func (q *Queries) CountIdPUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countIdPUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIdPUsersByQueryAndState = `-- name: CountIdPUsersByQueryAndState :one
SELECT count(*)
FROM accounts
WHERE
  source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND (
    $1::text = ''
    OR email ILIKE ('%' || $1::text || '%')
    OR display_name ILIKE ('%' || $1::text || '%')
    OR external_id ILIKE ('%' || $1::text || '%')
  )
  AND (
    $2::text = ''
    OR ($2::text = 'active' AND lower(status) = 'active')
    OR ($2::text = 'inactive' AND lower(status) <> 'active')
  )
`

type CountIdPUsersByQueryAndStateParams struct {
	Query string `json:"query"`
	State string `json:"state"`
}

func (q *Queries) CountIdPUsersByQueryAndState(ctx context.Context, arg CountIdPUsersByQueryAndStateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countIdPUsersByQueryAndState, arg.Query, arg.State)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getIdPUser = `-- name: GetIdPUser :one
SELECT id, source_kind, source_name, external_id, email, display_name, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, status
FROM accounts
WHERE id = $1
  AND source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

func (q *Queries) GetIdPUser(ctx context.Context, id int64) (Account, error) {
	row := q.db.QueryRow(ctx, getIdPUser, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.SourceKind,
		&i.SourceName,
		&i.ExternalID,
		&i.Email,
		&i.DisplayName,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.LastLoginRegion,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
		&i.Status,
	)
	return i, err
}

const listIdPUsers = `-- name: ListIdPUsers :many
SELECT id, source_kind, source_name, external_id, email, display_name, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, status
FROM accounts
WHERE source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
ORDER BY id ASC
`

func (q *Queries) ListIdPUsers(ctx context.Context) ([]Account, error) {
	rows, err := q.db.Query(ctx, listIdPUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIdPUsersForCommand = `-- name: ListIdPUsersForCommand :many
SELECT
  id,
  email,
  display_name,
  status
FROM accounts
WHERE source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
ORDER BY
  (lower(status) = 'active') DESC,
  lower(COALESCE(NULLIF(trim(display_name), ''), email)) ASC,
  lower(email) ASC,
  id ASC
LIMIT 200
`

type ListIdPUsersForCommandRow struct {
	ID          int64  `json:"id"`
	Email       string `json:"email"`
	DisplayName string `json:"display_name"`
	Status      string `json:"status"`
}

func (q *Queries) ListIdPUsersForCommand(ctx context.Context) ([]ListIdPUsersForCommandRow, error) {
	rows, err := q.db.Query(ctx, listIdPUsersForCommand)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIdPUsersForCommandRow
	for rows.Next() {
		var i ListIdPUsersForCommandRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.DisplayName,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIdPUsersPageByQueryAndState = `-- name: ListIdPUsersPageByQueryAndState :many
SELECT id, source_kind, source_name, external_id, email, display_name, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, status
FROM accounts
WHERE
  source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND (
    $1::text = ''
    OR email ILIKE ('%' || $1::text || '%')
    OR display_name ILIKE ('%' || $1::text || '%')
    OR external_id ILIKE ('%' || $1::text || '%')
  )
  AND (
    $2::text = ''
    OR ($2::text = 'active' AND lower(status) = 'active')
    OR ($2::text = 'inactive' AND lower(status) <> 'active')
  )
ORDER BY id ASC
LIMIT $4::int
OFFSET $3::int
`

type ListIdPUsersPageByQueryAndStateParams struct {
	Query      string `json:"query"`
	State      string `json:"state"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

func (q *Queries) ListIdPUsersPageByQueryAndState(ctx context.Context, arg ListIdPUsersPageByQueryAndStateParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listIdPUsersPageByQueryAndState,
		arg.Query,
		arg.State,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertIdPUsersBulk = `-- name: UpsertIdPUsersBulk :execrows

WITH sync_source AS (
  SELECT COALESCE(NULLIF(trim(sr.source_name), ''), 'okta') AS source_name
  FROM sync_runs sr
  WHERE sr.id = $1::bigint
  LIMIT 1
),
input AS (
  SELECT
    i,
    ($2::text[])[i] AS external_id,
    lower(trim(($3::text[])[i])) AS email,
    ($4::text[])[i] AS display_name,
    ($5::text[])[i] AS status,
    ($6::jsonb[])[i] AS raw_json,
    ($7::timestamptz[])[i] AS last_login_at,
    ($8::text[])[i] AS last_login_ip,
    ($9::text[])[i] AS last_login_region
  FROM generate_subscripts($2::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (external_id)
    external_id,
    email,
    display_name,
    status,
    raw_json,
    last_login_at,
    last_login_ip,
    last_login_region
  FROM input
  ORDER BY external_id, i DESC
)
INSERT INTO accounts (
  source_kind,
  source_name,
  external_id,
  email,
  display_name,
  status,
  raw_json,
  last_login_at,
  last_login_ip,
  last_login_region,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  'okta',
  COALESCE((SELECT source_name FROM sync_source), 'okta'),
  input.external_id,
  input.email,
  input.display_name,
  input.status,
  input.raw_json,
  input.last_login_at,
  input.last_login_ip,
  input.last_login_region,
  $1::bigint,
  now(),
  now()
FROM dedup input
ON CONFLICT (source_kind, source_name, external_id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name,
  status = EXCLUDED.status,
  raw_json = EXCLUDED.raw_json,
  last_login_at = COALESCE(EXCLUDED.last_login_at, accounts.last_login_at),
  last_login_ip = COALESCE(NULLIF(EXCLUDED.last_login_ip, ''), accounts.last_login_ip),
  last_login_region = COALESCE(NULLIF(EXCLUDED.last_login_region, ''), accounts.last_login_region),
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertIdPUsersBulkParams struct {
	SeenInRunID      int64                `json:"seen_in_run_id"`
	ExternalIds      []string             `json:"external_ids"`
	Emails           []string             `json:"emails"`
	DisplayNames     []string             `json:"display_names"`
	Statuses         []string             `json:"statuses"`
	RawJsons         [][]byte             `json:"raw_jsons"`
	LastLoginAts     []pgtype.Timestamptz `json:"last_login_ats"`
	LastLoginIps     []string             `json:"last_login_ips"`
	LastLoginRegions []string             `json:"last_login_regions"`
}

// Legacy IdP query names now backed by Okta accounts in accounts.
func (q *Queries) UpsertIdPUsersBulk(ctx context.Context, arg UpsertIdPUsersBulkParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertIdPUsersBulk,
		arg.SeenInRunID,
		arg.ExternalIds,
		arg.Emails,
		arg.DisplayNames,
		arg.Statuses,
		arg.RawJsons,
		arg.LastLoginAts,
		arg.LastLoginIps,
		arg.LastLoginRegions,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

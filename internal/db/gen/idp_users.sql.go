// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: idp_users.sql

package gen

import (
	"context"
)

const countIdPUsers = `-- name: CountIdPUsers :one
SELECT count(*)
FROM accounts
WHERE source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

func (q *Queries) CountIdPUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countIdPUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIdPUsersByQueryAndState = `-- name: CountIdPUsersByQueryAndState :one
SELECT count(*)
FROM accounts
WHERE
  source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND (
    $1::text = ''
    OR email ILIKE ('%' || $1::text || '%')
    OR display_name ILIKE ('%' || $1::text || '%')
    OR external_id ILIKE ('%' || $1::text || '%')
  )
  AND (
    $2::text = ''
    OR ($2::text = 'active' AND lower(status) = 'active')
    OR ($2::text = 'inactive' AND lower(status) <> 'active')
  )
`

type CountIdPUsersByQueryAndStateParams struct {
	Query string `json:"query"`
	State string `json:"state"`
}

func (q *Queries) CountIdPUsersByQueryAndState(ctx context.Context, arg CountIdPUsersByQueryAndStateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countIdPUsersByQueryAndState, arg.Query, arg.State)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getIdPUser = `-- name: GetIdPUser :one

SELECT id, source_kind, source_name, external_id, email, display_name, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, status, account_kind
FROM accounts
WHERE id = $1
  AND source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

// Legacy IdP query names now backed by Okta accounts in accounts.
func (q *Queries) GetIdPUser(ctx context.Context, id int64) (Account, error) {
	row := q.db.QueryRow(ctx, getIdPUser, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.SourceKind,
		&i.SourceName,
		&i.ExternalID,
		&i.Email,
		&i.DisplayName,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.LastLoginRegion,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
		&i.Status,
		&i.AccountKind,
	)
	return i, err
}

const listIdPUsersForCommand = `-- name: ListIdPUsersForCommand :many
SELECT
  id,
  email,
  display_name,
  status
FROM accounts
WHERE source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
ORDER BY
  (lower(status) = 'active') DESC,
  lower(COALESCE(NULLIF(trim(display_name), ''), email)) ASC,
  lower(email) ASC,
  id ASC
LIMIT 200
`

type ListIdPUsersForCommandRow struct {
	ID          int64  `json:"id"`
	Email       string `json:"email"`
	DisplayName string `json:"display_name"`
	Status      string `json:"status"`
}

func (q *Queries) ListIdPUsersForCommand(ctx context.Context) ([]ListIdPUsersForCommandRow, error) {
	rows, err := q.db.Query(ctx, listIdPUsersForCommand)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIdPUsersForCommandRow
	for rows.Next() {
		var i ListIdPUsersForCommandRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.DisplayName,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIdPUsersPageByQueryAndState = `-- name: ListIdPUsersPageByQueryAndState :many
SELECT id, source_kind, source_name, external_id, email, display_name, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, status, account_kind
FROM accounts
WHERE
  source_kind = 'okta'
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND (
    $1::text = ''
    OR email ILIKE ('%' || $1::text || '%')
    OR display_name ILIKE ('%' || $1::text || '%')
    OR external_id ILIKE ('%' || $1::text || '%')
  )
  AND (
    $2::text = ''
    OR ($2::text = 'active' AND lower(status) = 'active')
    OR ($2::text = 'inactive' AND lower(status) <> 'active')
  )
ORDER BY id ASC
LIMIT $4::int
OFFSET $3::int
`

type ListIdPUsersPageByQueryAndStateParams struct {
	Query      string `json:"query"`
	State      string `json:"state"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

func (q *Queries) ListIdPUsersPageByQueryAndState(ctx context.Context, arg ListIdPUsersPageByQueryAndStateParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listIdPUsersPageByQueryAndState,
		arg.Query,
		arg.State,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
			&i.AccountKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

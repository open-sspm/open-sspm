// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: app_asset_owners.sql

package gen

import (
	"context"
)

const countAppAssetOwnersByAssetID = `-- name: CountAppAssetOwnersByAssetID :one
SELECT count(*)
FROM app_asset_owners
WHERE app_asset_id = $1
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

func (q *Queries) CountAppAssetOwnersByAssetID(ctx context.Context, appAssetID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countAppAssetOwnersByAssetID, appAssetID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const expireAppAssetOwnersNotSeenInRunBySource = `-- name: ExpireAppAssetOwnersNotSeenInRunBySource :execrows
UPDATE app_asset_owners aao
SET
  expired_at = now(),
  expired_run_id = $1::bigint
FROM app_assets aa
WHERE aa.id = aao.app_asset_id
  AND aa.source_kind = $2::text
  AND aa.source_name = $3::text
  AND aao.expired_at IS NULL
  AND aao.last_observed_run_id IS NOT NULL
  AND (
    aao.seen_in_run_id <> $1::bigint
    OR aao.seen_in_run_id IS NULL
  )
`

type ExpireAppAssetOwnersNotSeenInRunBySourceParams struct {
	ExpiredRunID int64  `json:"expired_run_id"`
	SourceKind   string `json:"source_kind"`
	SourceName   string `json:"source_name"`
}

func (q *Queries) ExpireAppAssetOwnersNotSeenInRunBySource(ctx context.Context, arg ExpireAppAssetOwnersNotSeenInRunBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, expireAppAssetOwnersNotSeenInRunBySource, arg.ExpiredRunID, arg.SourceKind, arg.SourceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listAppAssetOwnersByAssetID = `-- name: ListAppAssetOwnersByAssetID :many
SELECT id, app_asset_id, owner_kind, owner_external_id, owner_display_name, owner_email, raw_json, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, created_at, updated_at
FROM app_asset_owners
WHERE app_asset_id = $1
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
ORDER BY
  lower(COALESCE(NULLIF(trim(owner_display_name), ''), NULLIF(trim(owner_email), ''), owner_external_id)) ASC,
  id ASC
`

func (q *Queries) ListAppAssetOwnersByAssetID(ctx context.Context, appAssetID int64) ([]AppAssetOwner, error) {
	rows, err := q.db.Query(ctx, listAppAssetOwnersByAssetID, appAssetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppAssetOwner
	for rows.Next() {
		var i AppAssetOwner
		if err := rows.Scan(
			&i.ID,
			&i.AppAssetID,
			&i.OwnerKind,
			&i.OwnerExternalID,
			&i.OwnerDisplayName,
			&i.OwnerEmail,
			&i.RawJson,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppAssetOwnersByAssetIDs = `-- name: ListAppAssetOwnersByAssetIDs :many
SELECT id, app_asset_id, owner_kind, owner_external_id, owner_display_name, owner_email, raw_json, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, created_at, updated_at
FROM app_asset_owners
WHERE app_asset_id = ANY($1::bigint[])
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
ORDER BY app_asset_id ASC, id ASC
`

func (q *Queries) ListAppAssetOwnersByAssetIDs(ctx context.Context, assetIds []int64) ([]AppAssetOwner, error) {
	rows, err := q.db.Query(ctx, listAppAssetOwnersByAssetIDs, assetIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppAssetOwner
	for rows.Next() {
		var i AppAssetOwner
		if err := rows.Scan(
			&i.ID,
			&i.AppAssetID,
			&i.OwnerKind,
			&i.OwnerExternalID,
			&i.OwnerDisplayName,
			&i.OwnerEmail,
			&i.RawJson,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const promoteAppAssetOwnersSeenInRunBySource = `-- name: PromoteAppAssetOwnersSeenInRunBySource :execrows
UPDATE app_asset_owners aao
SET
  last_observed_run_id = $1::bigint,
  last_observed_at = now(),
  expired_at = NULL,
  expired_run_id = NULL
FROM app_assets aa
WHERE aa.id = aao.app_asset_id
  AND aa.source_kind = $2::text
  AND aa.source_name = $3::text
  AND aao.seen_in_run_id = $1::bigint
`

type PromoteAppAssetOwnersSeenInRunBySourceParams struct {
	LastObservedRunID int64  `json:"last_observed_run_id"`
	SourceKind        string `json:"source_kind"`
	SourceName        string `json:"source_name"`
}

func (q *Queries) PromoteAppAssetOwnersSeenInRunBySource(ctx context.Context, arg PromoteAppAssetOwnersSeenInRunBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, promoteAppAssetOwnersSeenInRunBySource, arg.LastObservedRunID, arg.SourceKind, arg.SourceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertAppAssetOwnersBulkBySource = `-- name: UpsertAppAssetOwnersBulkBySource :execrows
WITH input AS (
  SELECT
    i,
    ($4::text[])[i] AS asset_kind,
    ($5::text[])[i] AS asset_external_id,
    ($6::text[])[i] AS owner_kind,
    ($7::text[])[i] AS owner_external_id,
    ($8::text[])[i] AS owner_display_name,
    ($9::text[])[i] AS owner_email,
    ($10::jsonb[])[i] AS raw_json
  FROM generate_subscripts($5::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (asset_kind, asset_external_id, owner_kind, owner_external_id)
    asset_kind,
    asset_external_id,
    owner_kind,
    owner_external_id,
    owner_display_name,
    owner_email,
    raw_json
  FROM input
  ORDER BY asset_kind, asset_external_id, owner_kind, owner_external_id, i DESC
)
INSERT INTO app_asset_owners (
  app_asset_id,
  owner_kind,
  owner_external_id,
  owner_display_name,
  owner_email,
  raw_json,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  aa.id,
  input.owner_kind,
  input.owner_external_id,
  input.owner_display_name,
  input.owner_email,
  input.raw_json,
  $1::bigint,
  now(),
  now()
FROM dedup input
JOIN app_assets aa
  ON aa.source_kind = $2::text
  AND aa.source_name = $3::text
  AND aa.asset_kind = input.asset_kind
  AND aa.external_id = input.asset_external_id
ON CONFLICT (app_asset_id, owner_kind, owner_external_id) DO UPDATE SET
  owner_display_name = EXCLUDED.owner_display_name,
  owner_email = EXCLUDED.owner_email,
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertAppAssetOwnersBulkBySourceParams struct {
	SeenInRunID       int64    `json:"seen_in_run_id"`
	SourceKind        string   `json:"source_kind"`
	SourceName        string   `json:"source_name"`
	AssetKinds        []string `json:"asset_kinds"`
	AssetExternalIds  []string `json:"asset_external_ids"`
	OwnerKinds        []string `json:"owner_kinds"`
	OwnerExternalIds  []string `json:"owner_external_ids"`
	OwnerDisplayNames []string `json:"owner_display_names"`
	OwnerEmails       []string `json:"owner_emails"`
	RawJsons          [][]byte `json:"raw_jsons"`
}

func (q *Queries) UpsertAppAssetOwnersBulkBySource(ctx context.Context, arg UpsertAppAssetOwnersBulkBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertAppAssetOwnersBulkBySource,
		arg.SeenInRunID,
		arg.SourceKind,
		arg.SourceName,
		arg.AssetKinds,
		arg.AssetExternalIds,
		arg.OwnerKinds,
		arg.OwnerExternalIds,
		arg.OwnerDisplayNames,
		arg.OwnerEmails,
		arg.RawJsons,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rules_engine.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deactivateRulesNotInKeys = `-- name: DeactivateRulesNotInKeys :exec
UPDATE rules
SET is_active = false, updated_at = now()
WHERE ruleset_id = $1
  AND NOT (key = ANY($2::text[]))
`

type DeactivateRulesNotInKeysParams struct {
	RulesetID int64    `json:"ruleset_id"`
	RuleKeys  []string `json:"rule_keys"`
}

func (q *Queries) DeactivateRulesNotInKeys(ctx context.Context, arg DeactivateRulesNotInKeysParams) error {
	_, err := q.db.Exec(ctx, deactivateRulesNotInKeys, arg.RulesetID, arg.RuleKeys)
	return err
}

const deleteRuleAttestation = `-- name: DeleteRuleAttestation :exec
DELETE FROM rule_attestations
WHERE rule_id = $1
  AND scope_kind = $2
  AND source_kind = $3
  AND source_name = $4
`

type DeleteRuleAttestationParams struct {
	RuleID     int64  `json:"rule_id"`
	ScopeKind  string `json:"scope_kind"`
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) DeleteRuleAttestation(ctx context.Context, arg DeleteRuleAttestationParams) error {
	_, err := q.db.Exec(ctx, deleteRuleAttestation,
		arg.RuleID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
	)
	return err
}

const deleteRuleOverride = `-- name: DeleteRuleOverride :exec
DELETE FROM rule_overrides
WHERE rule_id = $1
  AND scope_kind = $2
  AND source_kind = $3
  AND source_name = $4
`

type DeleteRuleOverrideParams struct {
	RuleID     int64  `json:"rule_id"`
	ScopeKind  string `json:"scope_kind"`
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) DeleteRuleOverride(ctx context.Context, arg DeleteRuleOverrideParams) error {
	_, err := q.db.Exec(ctx, deleteRuleOverride,
		arg.RuleID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
	)
	return err
}

const deleteRulesetOverride = `-- name: DeleteRulesetOverride :exec
DELETE FROM ruleset_overrides
WHERE ruleset_id = $1
  AND scope_kind = $2
  AND source_kind = $3
  AND source_name = $4
`

type DeleteRulesetOverrideParams struct {
	RulesetID  int64  `json:"ruleset_id"`
	ScopeKind  string `json:"scope_kind"`
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) DeleteRulesetOverride(ctx context.Context, arg DeleteRulesetOverrideParams) error {
	_, err := q.db.Exec(ctx, deleteRulesetOverride,
		arg.RulesetID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
	)
	return err
}

const getRuleAttestation = `-- name: GetRuleAttestation :one
SELECT id, rule_id, scope_kind, source_kind, source_name, status, notes, expires_at, created_at, updated_at
FROM rule_attestations
WHERE rule_id = $1
  AND scope_kind = $2
  AND source_kind = $3
  AND source_name = $4
`

type GetRuleAttestationParams struct {
	RuleID     int64  `json:"rule_id"`
	ScopeKind  string `json:"scope_kind"`
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) GetRuleAttestation(ctx context.Context, arg GetRuleAttestationParams) (RuleAttestation, error) {
	row := q.db.QueryRow(ctx, getRuleAttestation,
		arg.RuleID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
	)
	var i RuleAttestation
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.ScopeKind,
		&i.SourceKind,
		&i.SourceName,
		&i.Status,
		&i.Notes,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRuleOverride = `-- name: GetRuleOverride :one
SELECT id, rule_id, scope_kind, source_kind, source_name, params, enabled, created_at, updated_at
FROM rule_overrides
WHERE rule_id = $1
  AND scope_kind = $2
  AND source_kind = $3
  AND source_name = $4
`

type GetRuleOverrideParams struct {
	RuleID     int64  `json:"rule_id"`
	ScopeKind  string `json:"scope_kind"`
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) GetRuleOverride(ctx context.Context, arg GetRuleOverrideParams) (RuleOverride, error) {
	row := q.db.QueryRow(ctx, getRuleOverride,
		arg.RuleID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
	)
	var i RuleOverride
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.ScopeKind,
		&i.SourceKind,
		&i.SourceName,
		&i.Params,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRuleWithCurrentResultByRulesetKeyAndRuleKey = `-- name: GetRuleWithCurrentResultByRulesetKeyAndRuleKey :one
SELECT
  r.id, r.ruleset_id, r.key, r.title, r.summary, r.category, r.severity, r.monitoring_status, r.monitoring_reason, r.required_data, r.expected_params, r.rule_version, r.is_active, r.created_at, r.updated_at, r.definition_json,
  COALESCE(rrc.status, 'unknown') AS current_status,
  rrc.evaluated_at AS current_evaluated_at,
  rrc.sync_run_id AS current_sync_run_id,
  COALESCE(rrc.evidence_summary, '') AS current_evidence_summary,
  COALESCE(rrc.evidence_json, '{}'::jsonb) AS current_evidence_json,
  COALESCE(rrc.error_kind, '') AS current_error_kind
FROM rules r
JOIN rulesets rs ON rs.id = r.ruleset_id
LEFT JOIN rule_results_current rrc
  ON rrc.rule_id = r.id
  AND rrc.scope_kind = $3
  AND rrc.source_kind = $4
  AND rrc.source_name = $5
WHERE rs.key = $1
  AND r.key = $2
`

type GetRuleWithCurrentResultByRulesetKeyAndRuleKeyParams struct {
	Key        string `json:"key"`
	Key_2      string `json:"key_2"`
	ScopeKind  string `json:"scope_kind"`
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

type GetRuleWithCurrentResultByRulesetKeyAndRuleKeyRow struct {
	ID                     int64              `json:"id"`
	RulesetID              int64              `json:"ruleset_id"`
	Key                    string             `json:"key"`
	Title                  string             `json:"title"`
	Summary                string             `json:"summary"`
	Category               string             `json:"category"`
	Severity               string             `json:"severity"`
	MonitoringStatus       string             `json:"monitoring_status"`
	MonitoringReason       string             `json:"monitoring_reason"`
	RequiredData           []byte             `json:"required_data"`
	ExpectedParams         []byte             `json:"expected_params"`
	RuleVersion            string             `json:"rule_version"`
	IsActive               bool               `json:"is_active"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	DefinitionJson         []byte             `json:"definition_json"`
	CurrentStatus          string             `json:"current_status"`
	CurrentEvaluatedAt     pgtype.Timestamptz `json:"current_evaluated_at"`
	CurrentSyncRunID       pgtype.Int8        `json:"current_sync_run_id"`
	CurrentEvidenceSummary string             `json:"current_evidence_summary"`
	CurrentEvidenceJson    []byte             `json:"current_evidence_json"`
	CurrentErrorKind       string             `json:"current_error_kind"`
}

func (q *Queries) GetRuleWithCurrentResultByRulesetKeyAndRuleKey(ctx context.Context, arg GetRuleWithCurrentResultByRulesetKeyAndRuleKeyParams) (GetRuleWithCurrentResultByRulesetKeyAndRuleKeyRow, error) {
	row := q.db.QueryRow(ctx, getRuleWithCurrentResultByRulesetKeyAndRuleKey,
		arg.Key,
		arg.Key_2,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
	)
	var i GetRuleWithCurrentResultByRulesetKeyAndRuleKeyRow
	err := row.Scan(
		&i.ID,
		&i.RulesetID,
		&i.Key,
		&i.Title,
		&i.Summary,
		&i.Category,
		&i.Severity,
		&i.MonitoringStatus,
		&i.MonitoringReason,
		&i.RequiredData,
		&i.ExpectedParams,
		&i.RuleVersion,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefinitionJson,
		&i.CurrentStatus,
		&i.CurrentEvaluatedAt,
		&i.CurrentSyncRunID,
		&i.CurrentEvidenceSummary,
		&i.CurrentEvidenceJson,
		&i.CurrentErrorKind,
	)
	return i, err
}

const getRulesetByKey = `-- name: GetRulesetByKey :one
SELECT id, key, name, description, source, source_version, source_date, scope_kind, connector_kind, status, definition_hash, created_at, updated_at, definition_json
FROM rulesets
WHERE key = $1
`

func (q *Queries) GetRulesetByKey(ctx context.Context, key string) (Ruleset, error) {
	row := q.db.QueryRow(ctx, getRulesetByKey, key)
	var i Ruleset
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Name,
		&i.Description,
		&i.Source,
		&i.SourceVersion,
		&i.SourceDate,
		&i.ScopeKind,
		&i.ConnectorKind,
		&i.Status,
		&i.DefinitionHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefinitionJson,
	)
	return i, err
}

const getRulesetOverride = `-- name: GetRulesetOverride :one
SELECT id, ruleset_id, scope_kind, source_kind, source_name, enabled, created_at, updated_at
FROM ruleset_overrides
WHERE ruleset_id = $1
  AND scope_kind = $2
  AND source_kind = $3
  AND source_name = $4
`

type GetRulesetOverrideParams struct {
	RulesetID  int64  `json:"ruleset_id"`
	ScopeKind  string `json:"scope_kind"`
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) GetRulesetOverride(ctx context.Context, arg GetRulesetOverrideParams) (RulesetOverride, error) {
	row := q.db.QueryRow(ctx, getRulesetOverride,
		arg.RulesetID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
	)
	var i RulesetOverride
	err := row.Scan(
		&i.ID,
		&i.RulesetID,
		&i.ScopeKind,
		&i.SourceKind,
		&i.SourceName,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertRuleEvaluation = `-- name: InsertRuleEvaluation :one
INSERT INTO rule_evaluations (
  rule_id,
  scope_kind,
  source_kind,
  source_name,
  status,
  sync_run_id,
  evaluated_at,
  evidence_summary,
  evidence_json,
  affected_resource_ids,
  error_kind
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, rule_id, scope_kind, source_kind, source_name, status, sync_run_id, evaluated_at, evidence_summary, evidence_json, affected_resource_ids, error_kind
`

type InsertRuleEvaluationParams struct {
	RuleID              int64              `json:"rule_id"`
	ScopeKind           string             `json:"scope_kind"`
	SourceKind          string             `json:"source_kind"`
	SourceName          string             `json:"source_name"`
	Status              string             `json:"status"`
	SyncRunID           pgtype.Int8        `json:"sync_run_id"`
	EvaluatedAt         pgtype.Timestamptz `json:"evaluated_at"`
	EvidenceSummary     string             `json:"evidence_summary"`
	EvidenceJson        []byte             `json:"evidence_json"`
	AffectedResourceIds []string           `json:"affected_resource_ids"`
	ErrorKind           string             `json:"error_kind"`
}

func (q *Queries) InsertRuleEvaluation(ctx context.Context, arg InsertRuleEvaluationParams) (RuleEvaluation, error) {
	row := q.db.QueryRow(ctx, insertRuleEvaluation,
		arg.RuleID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
		arg.Status,
		arg.SyncRunID,
		arg.EvaluatedAt,
		arg.EvidenceSummary,
		arg.EvidenceJson,
		arg.AffectedResourceIds,
		arg.ErrorKind,
	)
	var i RuleEvaluation
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.ScopeKind,
		&i.SourceKind,
		&i.SourceName,
		&i.Status,
		&i.SyncRunID,
		&i.EvaluatedAt,
		&i.EvidenceSummary,
		&i.EvidenceJson,
		&i.AffectedResourceIds,
		&i.ErrorKind,
	)
	return i, err
}

const listActiveRulesByRulesetID = `-- name: ListActiveRulesByRulesetID :many
SELECT id, ruleset_id, key, title, summary, category, severity, monitoring_status, monitoring_reason, required_data, expected_params, rule_version, is_active, created_at, updated_at, definition_json
FROM rules
WHERE ruleset_id = $1 AND is_active = true
ORDER BY key
`

func (q *Queries) ListActiveRulesByRulesetID(ctx context.Context, rulesetID int64) ([]Rule, error) {
	rows, err := q.db.Query(ctx, listActiveRulesByRulesetID, rulesetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rule
	for rows.Next() {
		var i Rule
		if err := rows.Scan(
			&i.ID,
			&i.RulesetID,
			&i.Key,
			&i.Title,
			&i.Summary,
			&i.Category,
			&i.Severity,
			&i.MonitoringStatus,
			&i.MonitoringReason,
			&i.RequiredData,
			&i.ExpectedParams,
			&i.RuleVersion,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DefinitionJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveRulesWithCurrentResultsByRulesetKey = `-- name: ListActiveRulesWithCurrentResultsByRulesetKey :many
SELECT
  r.id,
  r.ruleset_id,
  r.key,
  r.title,
  r.summary,
  r.category,
  r.severity,
  r.monitoring_status,
  r.monitoring_reason,
  r.required_data,
  r.expected_params,
  r.rule_version,
  r.is_active,
  r.definition_json,
  r.created_at,
  r.updated_at,
  COALESCE(rrc.status, 'unknown') AS current_status,
  rrc.evaluated_at AS current_evaluated_at,
  rrc.sync_run_id AS current_sync_run_id,
  COALESCE(rrc.evidence_summary, '') AS current_evidence_summary,
  COALESCE(rrc.error_kind, '') AS current_error_kind
FROM rules r
JOIN rulesets rs ON rs.id = r.ruleset_id
LEFT JOIN rule_results_current rrc
  ON rrc.rule_id = r.id
  AND rrc.scope_kind = $2
  AND rrc.source_kind = $3
  AND rrc.source_name = $4
WHERE rs.key = $1
  AND r.is_active = true
ORDER BY r.key
`

type ListActiveRulesWithCurrentResultsByRulesetKeyParams struct {
	Key        string `json:"key"`
	ScopeKind  string `json:"scope_kind"`
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

type ListActiveRulesWithCurrentResultsByRulesetKeyRow struct {
	ID                     int64              `json:"id"`
	RulesetID              int64              `json:"ruleset_id"`
	Key                    string             `json:"key"`
	Title                  string             `json:"title"`
	Summary                string             `json:"summary"`
	Category               string             `json:"category"`
	Severity               string             `json:"severity"`
	MonitoringStatus       string             `json:"monitoring_status"`
	MonitoringReason       string             `json:"monitoring_reason"`
	RequiredData           []byte             `json:"required_data"`
	ExpectedParams         []byte             `json:"expected_params"`
	RuleVersion            string             `json:"rule_version"`
	IsActive               bool               `json:"is_active"`
	DefinitionJson         []byte             `json:"definition_json"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	CurrentStatus          string             `json:"current_status"`
	CurrentEvaluatedAt     pgtype.Timestamptz `json:"current_evaluated_at"`
	CurrentSyncRunID       pgtype.Int8        `json:"current_sync_run_id"`
	CurrentEvidenceSummary string             `json:"current_evidence_summary"`
	CurrentErrorKind       string             `json:"current_error_kind"`
}

func (q *Queries) ListActiveRulesWithCurrentResultsByRulesetKey(ctx context.Context, arg ListActiveRulesWithCurrentResultsByRulesetKeyParams) ([]ListActiveRulesWithCurrentResultsByRulesetKeyRow, error) {
	rows, err := q.db.Query(ctx, listActiveRulesWithCurrentResultsByRulesetKey,
		arg.Key,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveRulesWithCurrentResultsByRulesetKeyRow
	for rows.Next() {
		var i ListActiveRulesWithCurrentResultsByRulesetKeyRow
		if err := rows.Scan(
			&i.ID,
			&i.RulesetID,
			&i.Key,
			&i.Title,
			&i.Summary,
			&i.Category,
			&i.Severity,
			&i.MonitoringStatus,
			&i.MonitoringReason,
			&i.RequiredData,
			&i.ExpectedParams,
			&i.RuleVersion,
			&i.IsActive,
			&i.DefinitionJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CurrentStatus,
			&i.CurrentEvaluatedAt,
			&i.CurrentSyncRunID,
			&i.CurrentEvidenceSummary,
			&i.CurrentErrorKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRulesets = `-- name: ListRulesets :many
SELECT id, key, name, description, source, source_version, source_date, scope_kind, connector_kind, status, definition_hash, created_at, updated_at, definition_json
FROM rulesets
ORDER BY key
`

func (q *Queries) ListRulesets(ctx context.Context) ([]Ruleset, error) {
	rows, err := q.db.Query(ctx, listRulesets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ruleset
	for rows.Next() {
		var i Ruleset
		if err := rows.Scan(
			&i.ID,
			&i.Key,
			&i.Name,
			&i.Description,
			&i.Source,
			&i.SourceVersion,
			&i.SourceDate,
			&i.ScopeKind,
			&i.ConnectorKind,
			&i.Status,
			&i.DefinitionHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DefinitionJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRule = `-- name: UpsertRule :one
INSERT INTO rules (
  ruleset_id,
  key,
  title,
  summary,
  category,
  severity,
  monitoring_status,
  monitoring_reason,
  required_data,
  expected_params,
  rule_version,
  is_active,
  definition_json
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
ON CONFLICT (ruleset_id, key) DO UPDATE SET
  title = EXCLUDED.title,
  summary = EXCLUDED.summary,
  category = EXCLUDED.category,
  severity = EXCLUDED.severity,
  monitoring_status = EXCLUDED.monitoring_status,
  monitoring_reason = EXCLUDED.monitoring_reason,
  required_data = EXCLUDED.required_data,
  expected_params = EXCLUDED.expected_params,
  rule_version = EXCLUDED.rule_version,
  is_active = EXCLUDED.is_active,
  definition_json = EXCLUDED.definition_json,
  updated_at = now()
RETURNING id, ruleset_id, key, title, summary, category, severity, monitoring_status, monitoring_reason, required_data, expected_params, rule_version, is_active, created_at, updated_at, definition_json
`

type UpsertRuleParams struct {
	RulesetID        int64  `json:"ruleset_id"`
	Key              string `json:"key"`
	Title            string `json:"title"`
	Summary          string `json:"summary"`
	Category         string `json:"category"`
	Severity         string `json:"severity"`
	MonitoringStatus string `json:"monitoring_status"`
	MonitoringReason string `json:"monitoring_reason"`
	RequiredData     []byte `json:"required_data"`
	ExpectedParams   []byte `json:"expected_params"`
	RuleVersion      string `json:"rule_version"`
	IsActive         bool   `json:"is_active"`
	DefinitionJson   []byte `json:"definition_json"`
}

func (q *Queries) UpsertRule(ctx context.Context, arg UpsertRuleParams) (Rule, error) {
	row := q.db.QueryRow(ctx, upsertRule,
		arg.RulesetID,
		arg.Key,
		arg.Title,
		arg.Summary,
		arg.Category,
		arg.Severity,
		arg.MonitoringStatus,
		arg.MonitoringReason,
		arg.RequiredData,
		arg.ExpectedParams,
		arg.RuleVersion,
		arg.IsActive,
		arg.DefinitionJson,
	)
	var i Rule
	err := row.Scan(
		&i.ID,
		&i.RulesetID,
		&i.Key,
		&i.Title,
		&i.Summary,
		&i.Category,
		&i.Severity,
		&i.MonitoringStatus,
		&i.MonitoringReason,
		&i.RequiredData,
		&i.ExpectedParams,
		&i.RuleVersion,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefinitionJson,
	)
	return i, err
}

const upsertRuleAttestation = `-- name: UpsertRuleAttestation :one
INSERT INTO rule_attestations (rule_id, scope_kind, source_kind, source_name, status, notes, expires_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (rule_id, scope_kind, source_kind, source_name) DO UPDATE SET
  status = EXCLUDED.status,
  notes = EXCLUDED.notes,
  expires_at = EXCLUDED.expires_at,
  updated_at = now()
RETURNING id, rule_id, scope_kind, source_kind, source_name, status, notes, expires_at, created_at, updated_at
`

type UpsertRuleAttestationParams struct {
	RuleID     int64              `json:"rule_id"`
	ScopeKind  string             `json:"scope_kind"`
	SourceKind string             `json:"source_kind"`
	SourceName string             `json:"source_name"`
	Status     string             `json:"status"`
	Notes      string             `json:"notes"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) UpsertRuleAttestation(ctx context.Context, arg UpsertRuleAttestationParams) (RuleAttestation, error) {
	row := q.db.QueryRow(ctx, upsertRuleAttestation,
		arg.RuleID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
		arg.Status,
		arg.Notes,
		arg.ExpiresAt,
	)
	var i RuleAttestation
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.ScopeKind,
		&i.SourceKind,
		&i.SourceName,
		&i.Status,
		&i.Notes,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertRuleOverride = `-- name: UpsertRuleOverride :one
INSERT INTO rule_overrides (rule_id, scope_kind, source_kind, source_name, params, enabled)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (rule_id, scope_kind, source_kind, source_name) DO UPDATE SET
  params = EXCLUDED.params,
  enabled = EXCLUDED.enabled,
  updated_at = now()
RETURNING id, rule_id, scope_kind, source_kind, source_name, params, enabled, created_at, updated_at
`

type UpsertRuleOverrideParams struct {
	RuleID     int64  `json:"rule_id"`
	ScopeKind  string `json:"scope_kind"`
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Params     []byte `json:"params"`
	Enabled    bool   `json:"enabled"`
}

func (q *Queries) UpsertRuleOverride(ctx context.Context, arg UpsertRuleOverrideParams) (RuleOverride, error) {
	row := q.db.QueryRow(ctx, upsertRuleOverride,
		arg.RuleID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
		arg.Params,
		arg.Enabled,
	)
	var i RuleOverride
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.ScopeKind,
		&i.SourceKind,
		&i.SourceName,
		&i.Params,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertRuleResultCurrent = `-- name: UpsertRuleResultCurrent :one
INSERT INTO rule_results_current (
  rule_id,
  scope_kind,
  source_kind,
  source_name,
  status,
  evaluated_at,
  sync_run_id,
  evidence_summary,
  evidence_json,
  affected_resource_ids,
  error_kind
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT (rule_id, scope_kind, source_kind, source_name) DO UPDATE SET
  status = EXCLUDED.status,
  evaluated_at = EXCLUDED.evaluated_at,
  sync_run_id = EXCLUDED.sync_run_id,
  evidence_summary = EXCLUDED.evidence_summary,
  evidence_json = EXCLUDED.evidence_json,
  affected_resource_ids = EXCLUDED.affected_resource_ids,
  error_kind = EXCLUDED.error_kind,
  updated_at = now()
RETURNING id, rule_id, scope_kind, source_kind, source_name, status, evaluated_at, sync_run_id, evidence_summary, evidence_json, affected_resource_ids, error_kind, created_at, updated_at
`

type UpsertRuleResultCurrentParams struct {
	RuleID              int64              `json:"rule_id"`
	ScopeKind           string             `json:"scope_kind"`
	SourceKind          string             `json:"source_kind"`
	SourceName          string             `json:"source_name"`
	Status              string             `json:"status"`
	EvaluatedAt         pgtype.Timestamptz `json:"evaluated_at"`
	SyncRunID           pgtype.Int8        `json:"sync_run_id"`
	EvidenceSummary     string             `json:"evidence_summary"`
	EvidenceJson        []byte             `json:"evidence_json"`
	AffectedResourceIds []string           `json:"affected_resource_ids"`
	ErrorKind           string             `json:"error_kind"`
}

func (q *Queries) UpsertRuleResultCurrent(ctx context.Context, arg UpsertRuleResultCurrentParams) (RuleResultsCurrent, error) {
	row := q.db.QueryRow(ctx, upsertRuleResultCurrent,
		arg.RuleID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
		arg.Status,
		arg.EvaluatedAt,
		arg.SyncRunID,
		arg.EvidenceSummary,
		arg.EvidenceJson,
		arg.AffectedResourceIds,
		arg.ErrorKind,
	)
	var i RuleResultsCurrent
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.ScopeKind,
		&i.SourceKind,
		&i.SourceName,
		&i.Status,
		&i.EvaluatedAt,
		&i.SyncRunID,
		&i.EvidenceSummary,
		&i.EvidenceJson,
		&i.AffectedResourceIds,
		&i.ErrorKind,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertRuleset = `-- name: UpsertRuleset :one
INSERT INTO rulesets (
  key,
  name,
  description,
  source,
  source_version,
  source_date,
  scope_kind,
  connector_kind,
  status,
  definition_hash,
  definition_json
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11
)
ON CONFLICT (key) DO UPDATE SET
  name = EXCLUDED.name,
  description = EXCLUDED.description,
  source = EXCLUDED.source,
  source_version = EXCLUDED.source_version,
  source_date = EXCLUDED.source_date,
  scope_kind = EXCLUDED.scope_kind,
  connector_kind = EXCLUDED.connector_kind,
  status = EXCLUDED.status,
  definition_hash = EXCLUDED.definition_hash,
  definition_json = EXCLUDED.definition_json,
  updated_at = now()
RETURNING id, key, name, description, source, source_version, source_date, scope_kind, connector_kind, status, definition_hash, created_at, updated_at, definition_json
`

type UpsertRulesetParams struct {
	Key            string      `json:"key"`
	Name           string      `json:"name"`
	Description    string      `json:"description"`
	Source         string      `json:"source"`
	SourceVersion  string      `json:"source_version"`
	SourceDate     pgtype.Date `json:"source_date"`
	ScopeKind      string      `json:"scope_kind"`
	ConnectorKind  pgtype.Text `json:"connector_kind"`
	Status         string      `json:"status"`
	DefinitionHash string      `json:"definition_hash"`
	DefinitionJson []byte      `json:"definition_json"`
}

func (q *Queries) UpsertRuleset(ctx context.Context, arg UpsertRulesetParams) (Ruleset, error) {
	row := q.db.QueryRow(ctx, upsertRuleset,
		arg.Key,
		arg.Name,
		arg.Description,
		arg.Source,
		arg.SourceVersion,
		arg.SourceDate,
		arg.ScopeKind,
		arg.ConnectorKind,
		arg.Status,
		arg.DefinitionHash,
		arg.DefinitionJson,
	)
	var i Ruleset
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.Name,
		&i.Description,
		&i.Source,
		&i.SourceVersion,
		&i.SourceDate,
		&i.ScopeKind,
		&i.ConnectorKind,
		&i.Status,
		&i.DefinitionHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefinitionJson,
	)
	return i, err
}

const upsertRulesetOverride = `-- name: UpsertRulesetOverride :one
INSERT INTO ruleset_overrides (ruleset_id, scope_kind, source_kind, source_name, enabled)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (ruleset_id, scope_kind, source_kind, source_name) DO UPDATE SET
  enabled = EXCLUDED.enabled,
  updated_at = now()
RETURNING id, ruleset_id, scope_kind, source_kind, source_name, enabled, created_at, updated_at
`

type UpsertRulesetOverrideParams struct {
	RulesetID  int64  `json:"ruleset_id"`
	ScopeKind  string `json:"scope_kind"`
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Enabled    bool   `json:"enabled"`
}

func (q *Queries) UpsertRulesetOverride(ctx context.Context, arg UpsertRulesetOverrideParams) (RulesetOverride, error) {
	row := q.db.QueryRow(ctx, upsertRulesetOverride,
		arg.RulesetID,
		arg.ScopeKind,
		arg.SourceKind,
		arg.SourceName,
		arg.Enabled,
	)
	var i RulesetOverride
	err := row.Scan(
		&i.ID,
		&i.RulesetID,
		&i.ScopeKind,
		&i.SourceKind,
		&i.SourceName,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

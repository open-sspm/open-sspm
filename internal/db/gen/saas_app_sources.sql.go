// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: saas_app_sources.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const expireSaaSAppSourcesNotSeenInRunBySource = `-- name: ExpireSaaSAppSourcesNotSeenInRunBySource :execrows
UPDATE saas_app_sources
SET
  expired_at = now(),
  expired_run_id = $1::bigint
WHERE source_kind = $2::text
  AND source_name = $3::text
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
  AND COALESCE(last_observed_at, seen_at, created_at) < now() - interval '30 days'
`

type ExpireSaaSAppSourcesNotSeenInRunBySourceParams struct {
	ExpiredRunID int64  `json:"expired_run_id"`
	SourceKind   string `json:"source_kind"`
	SourceName   string `json:"source_name"`
}

func (q *Queries) ExpireSaaSAppSourcesNotSeenInRunBySource(ctx context.Context, arg ExpireSaaSAppSourcesNotSeenInRunBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, expireSaaSAppSourcesNotSeenInRunBySource, arg.ExpiredRunID, arg.SourceKind, arg.SourceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listEntraDiscoveryAppIDsWithManagedAssetsBySource = `-- name: ListEntraDiscoveryAppIDsWithManagedAssetsBySource :many
SELECT DISTINCT sas.saas_app_id
FROM saas_app_sources sas
JOIN app_assets aa
  ON aa.source_kind = 'entra'
 AND aa.source_name = sas.source_name
 AND aa.expired_at IS NULL
 AND aa.last_observed_run_id IS NOT NULL
 AND aa.asset_kind IN ('entra_application', 'entra_service_principal')
 AND (
   aa.external_id = sas.source_app_id
   OR aa.parent_external_id = sas.source_app_id
   OR lower(aa.display_name) = lower(sas.source_app_name)
 )
WHERE sas.source_kind = 'entra'
  AND sas.source_name = $1::text
  AND sas.expired_at IS NULL
  AND sas.last_observed_run_id IS NOT NULL
ORDER BY sas.saas_app_id ASC
`

func (q *Queries) ListEntraDiscoveryAppIDsWithManagedAssetsBySource(ctx context.Context, sourceName string) ([]int64, error) {
	rows, err := q.db.Query(ctx, listEntraDiscoveryAppIDsWithManagedAssetsBySource, sourceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var saas_app_id int64
		if err := rows.Scan(&saas_app_id); err != nil {
			return nil, err
		}
		items = append(items, saas_app_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMappedOktaDiscoveryAppsBySource = `-- name: ListMappedOktaDiscoveryAppsBySource :many
SELECT DISTINCT
  sas.saas_app_id,
  m.integration_kind
FROM saas_app_sources sas
JOIN integration_okta_app_map m
  ON m.okta_app_external_id = sas.source_app_id
WHERE sas.source_kind = 'okta'
  AND sas.source_name = $1::text
  AND sas.expired_at IS NULL
  AND sas.last_observed_run_id IS NOT NULL
ORDER BY sas.saas_app_id ASC, m.integration_kind ASC
`

type ListMappedOktaDiscoveryAppsBySourceRow struct {
	SaasAppID       int64  `json:"saas_app_id"`
	IntegrationKind string `json:"integration_kind"`
}

func (q *Queries) ListMappedOktaDiscoveryAppsBySource(ctx context.Context, sourceName string) ([]ListMappedOktaDiscoveryAppsBySourceRow, error) {
	rows, err := q.db.Query(ctx, listMappedOktaDiscoveryAppsBySource, sourceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMappedOktaDiscoveryAppsBySourceRow
	for rows.Next() {
		var i ListMappedOktaDiscoveryAppsBySourceRow
		if err := rows.Scan(&i.SaasAppID, &i.IntegrationKind); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSaaSAppIDsFromSourcesSeenInRunBySource = `-- name: ListSaaSAppIDsFromSourcesSeenInRunBySource :many
SELECT DISTINCT saas_app_id
FROM saas_app_sources
WHERE source_kind = $1::text
  AND source_name = $2::text
  AND seen_in_run_id = $3::bigint
ORDER BY saas_app_id ASC
`

type ListSaaSAppIDsFromSourcesSeenInRunBySourceParams struct {
	SourceKind  string `json:"source_kind"`
	SourceName  string `json:"source_name"`
	SeenInRunID int64  `json:"seen_in_run_id"`
}

func (q *Queries) ListSaaSAppIDsFromSourcesSeenInRunBySource(ctx context.Context, arg ListSaaSAppIDsFromSourcesSeenInRunBySourceParams) ([]int64, error) {
	rows, err := q.db.Query(ctx, listSaaSAppIDsFromSourcesSeenInRunBySource, arg.SourceKind, arg.SourceName, arg.SeenInRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var saas_app_id int64
		if err := rows.Scan(&saas_app_id); err != nil {
			return nil, err
		}
		items = append(items, saas_app_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSaaSAppSourcesBySaaSAppID = `-- name: ListSaaSAppSourcesBySaaSAppID :many
SELECT id, saas_app_id, source_kind, source_name, source_app_id, source_app_name, source_app_domain, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, created_at, updated_at
FROM saas_app_sources
WHERE saas_app_id = $1
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
ORDER BY source_kind ASC, source_name ASC, lower(COALESCE(NULLIF(trim(source_app_name), ''), source_app_id)) ASC, id ASC
`

func (q *Queries) ListSaaSAppSourcesBySaaSAppID(ctx context.Context, saasAppID int64) ([]SaasAppSource, error) {
	rows, err := q.db.Query(ctx, listSaaSAppSourcesBySaaSAppID, saasAppID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SaasAppSource
	for rows.Next() {
		var i SaasAppSource
		if err := rows.Scan(
			&i.ID,
			&i.SaasAppID,
			&i.SourceKind,
			&i.SourceName,
			&i.SourceAppID,
			&i.SourceAppName,
			&i.SourceAppDomain,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const promoteSaaSAppSourcesSeenInRunBySource = `-- name: PromoteSaaSAppSourcesSeenInRunBySource :execrows
UPDATE saas_app_sources
SET
  last_observed_run_id = $1::bigint,
  last_observed_at = now(),
  expired_at = NULL,
  expired_run_id = NULL
WHERE source_kind = $2::text
  AND source_name = $3::text
  AND seen_in_run_id = $1::bigint
`

type PromoteSaaSAppSourcesSeenInRunBySourceParams struct {
	LastObservedRunID int64  `json:"last_observed_run_id"`
	SourceKind        string `json:"source_kind"`
	SourceName        string `json:"source_name"`
}

func (q *Queries) PromoteSaaSAppSourcesSeenInRunBySource(ctx context.Context, arg PromoteSaaSAppSourcesSeenInRunBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, promoteSaaSAppSourcesSeenInRunBySource, arg.LastObservedRunID, arg.SourceKind, arg.SourceName)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertSaaSAppSourcesBulkBySource = `-- name: UpsertSaaSAppSourcesBulkBySource :execrows
WITH input AS (
  SELECT
    i,
    $2::text AS source_kind,
    $3::text AS source_name,
    ($4::text[])[i] AS canonical_key,
    ($5::text[])[i] AS source_app_id,
    ($6::text[])[i] AS source_app_name,
    ($7::text[])[i] AS source_app_domain,
    ($8::timestamptz[])[i] AS seen_at
  FROM generate_subscripts($5::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (source_kind, source_name, source_app_id)
    source_kind,
    source_name,
    canonical_key,
    source_app_id,
    source_app_name,
    source_app_domain,
    seen_at
  FROM input
  WHERE trim(source_app_id) <> ''
  ORDER BY source_kind, source_name, source_app_id, i DESC
)
INSERT INTO saas_app_sources (
  saas_app_id,
  source_kind,
  source_name,
  source_app_id,
  source_app_name,
  source_app_domain,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  sa.id,
  d.source_kind,
  d.source_name,
  d.source_app_id,
  d.source_app_name,
  d.source_app_domain,
  $1::bigint,
  COALESCE(d.seen_at, now()),
  now()
FROM dedup d
JOIN saas_apps sa ON sa.canonical_key = d.canonical_key
ON CONFLICT (source_kind, source_name, source_app_id) DO UPDATE SET
  saas_app_id = EXCLUDED.saas_app_id,
  source_app_name = EXCLUDED.source_app_name,
  source_app_domain = EXCLUDED.source_app_domain,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertSaaSAppSourcesBulkBySourceParams struct {
	SeenInRunID      int64                `json:"seen_in_run_id"`
	SourceKind       string               `json:"source_kind"`
	SourceName       string               `json:"source_name"`
	CanonicalKeys    []string             `json:"canonical_keys"`
	SourceAppIds     []string             `json:"source_app_ids"`
	SourceAppNames   []string             `json:"source_app_names"`
	SourceAppDomains []string             `json:"source_app_domains"`
	SeenAts          []pgtype.Timestamptz `json:"seen_ats"`
}

func (q *Queries) UpsertSaaSAppSourcesBulkBySource(ctx context.Context, arg UpsertSaaSAppSourcesBulkBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertSaaSAppSourcesBulkBySource,
		arg.SeenInRunID,
		arg.SourceKind,
		arg.SourceName,
		arg.CanonicalKeys,
		arg.SourceAppIds,
		arg.SourceAppNames,
		arg.SourceAppDomains,
		arg.SeenAts,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

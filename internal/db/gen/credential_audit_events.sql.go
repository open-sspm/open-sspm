// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: credential_audit_events.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listCredentialAuditEventsForCredential = `-- name: ListCredentialAuditEventsForCredential :many
SELECT cae.id, cae.source_kind, cae.source_name, cae.event_external_id, cae.event_type, cae.event_time, cae.actor_kind, cae.actor_external_id, cae.actor_display_name, cae.target_kind, cae.target_external_id, cae.target_display_name, cae.credential_kind, cae.credential_external_id, cae.raw_json, cae.created_at
FROM credential_audit_events cae
WHERE cae.source_kind = $1::text
  AND cae.source_name = $2::text
  AND cae.credential_kind = $3::text
  AND cae.credential_external_id = $4::text
ORDER BY cae.event_time DESC, cae.id DESC
LIMIT $5::int
`

type ListCredentialAuditEventsForCredentialParams struct {
	SourceKind           string `json:"source_kind"`
	SourceName           string `json:"source_name"`
	CredentialKind       string `json:"credential_kind"`
	CredentialExternalID string `json:"credential_external_id"`
	LimitRows            int32  `json:"limit_rows"`
}

func (q *Queries) ListCredentialAuditEventsForCredential(ctx context.Context, arg ListCredentialAuditEventsForCredentialParams) ([]CredentialAuditEvent, error) {
	rows, err := q.db.Query(ctx, listCredentialAuditEventsForCredential,
		arg.SourceKind,
		arg.SourceName,
		arg.CredentialKind,
		arg.CredentialExternalID,
		arg.LimitRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CredentialAuditEvent
	for rows.Next() {
		var i CredentialAuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.EventExternalID,
			&i.EventType,
			&i.EventTime,
			&i.ActorKind,
			&i.ActorExternalID,
			&i.ActorDisplayName,
			&i.TargetKind,
			&i.TargetExternalID,
			&i.TargetDisplayName,
			&i.CredentialKind,
			&i.CredentialExternalID,
			&i.RawJson,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCredentialAuditEventsForTarget = `-- name: ListCredentialAuditEventsForTarget :many
SELECT cae.id, cae.source_kind, cae.source_name, cae.event_external_id, cae.event_type, cae.event_time, cae.actor_kind, cae.actor_external_id, cae.actor_display_name, cae.target_kind, cae.target_external_id, cae.target_display_name, cae.credential_kind, cae.credential_external_id, cae.raw_json, cae.created_at
FROM credential_audit_events cae
WHERE cae.source_kind = $1::text
  AND cae.source_name = $2::text
  AND cae.target_kind = $3::text
  AND cae.target_external_id = $4::text
ORDER BY cae.event_time DESC, cae.id DESC
LIMIT $5::int
`

type ListCredentialAuditEventsForTargetParams struct {
	SourceKind       string `json:"source_kind"`
	SourceName       string `json:"source_name"`
	TargetKind       string `json:"target_kind"`
	TargetExternalID string `json:"target_external_id"`
	LimitRows        int32  `json:"limit_rows"`
}

func (q *Queries) ListCredentialAuditEventsForTarget(ctx context.Context, arg ListCredentialAuditEventsForTargetParams) ([]CredentialAuditEvent, error) {
	rows, err := q.db.Query(ctx, listCredentialAuditEventsForTarget,
		arg.SourceKind,
		arg.SourceName,
		arg.TargetKind,
		arg.TargetExternalID,
		arg.LimitRows,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CredentialAuditEvent
	for rows.Next() {
		var i CredentialAuditEvent
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.EventExternalID,
			&i.EventType,
			&i.EventTime,
			&i.ActorKind,
			&i.ActorExternalID,
			&i.ActorDisplayName,
			&i.TargetKind,
			&i.TargetExternalID,
			&i.TargetDisplayName,
			&i.CredentialKind,
			&i.CredentialExternalID,
			&i.RawJson,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCredentialAuditEventsBulkBySource = `-- name: UpsertCredentialAuditEventsBulkBySource :execrows
WITH input AS (
  SELECT
    i,
    ($3::text[])[i] AS event_external_id,
    ($4::text[])[i] AS event_type,
    ($5::timestamptz[])[i] AS event_time,
    ($6::text[])[i] AS actor_kind,
    ($7::text[])[i] AS actor_external_id,
    ($8::text[])[i] AS actor_display_name,
    ($9::text[])[i] AS target_kind,
    ($10::text[])[i] AS target_external_id,
    ($11::text[])[i] AS target_display_name,
    ($12::text[])[i] AS credential_kind,
    ($13::text[])[i] AS credential_external_id,
    ($14::jsonb[])[i] AS raw_json
  FROM generate_subscripts($3::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (event_external_id)
    event_external_id,
    event_type,
    event_time,
    actor_kind,
    actor_external_id,
    actor_display_name,
    target_kind,
    target_external_id,
    target_display_name,
    credential_kind,
    credential_external_id,
    raw_json
  FROM input
  ORDER BY event_external_id, i DESC
)
INSERT INTO credential_audit_events (
  source_kind,
  source_name,
  event_external_id,
  event_type,
  event_time,
  actor_kind,
  actor_external_id,
  actor_display_name,
  target_kind,
  target_external_id,
  target_display_name,
  credential_kind,
  credential_external_id,
  raw_json
)
SELECT
  $1::text,
  $2::text,
  input.event_external_id,
  input.event_type,
  input.event_time,
  input.actor_kind,
  input.actor_external_id,
  input.actor_display_name,
  input.target_kind,
  input.target_external_id,
  input.target_display_name,
  input.credential_kind,
  input.credential_external_id,
  input.raw_json
FROM dedup input
ON CONFLICT (source_kind, source_name, event_external_id) DO UPDATE SET
  event_type = EXCLUDED.event_type,
  event_time = EXCLUDED.event_time,
  actor_kind = EXCLUDED.actor_kind,
  actor_external_id = EXCLUDED.actor_external_id,
  actor_display_name = EXCLUDED.actor_display_name,
  target_kind = EXCLUDED.target_kind,
  target_external_id = EXCLUDED.target_external_id,
  target_display_name = EXCLUDED.target_display_name,
  credential_kind = EXCLUDED.credential_kind,
  credential_external_id = EXCLUDED.credential_external_id,
  raw_json = EXCLUDED.raw_json
`

type UpsertCredentialAuditEventsBulkBySourceParams struct {
	SourceKind            string               `json:"source_kind"`
	SourceName            string               `json:"source_name"`
	EventExternalIds      []string             `json:"event_external_ids"`
	EventTypes            []string             `json:"event_types"`
	EventTimes            []pgtype.Timestamptz `json:"event_times"`
	ActorKinds            []string             `json:"actor_kinds"`
	ActorExternalIds      []string             `json:"actor_external_ids"`
	ActorDisplayNames     []string             `json:"actor_display_names"`
	TargetKinds           []string             `json:"target_kinds"`
	TargetExternalIds     []string             `json:"target_external_ids"`
	TargetDisplayNames    []string             `json:"target_display_names"`
	CredentialKinds       []string             `json:"credential_kinds"`
	CredentialExternalIds []string             `json:"credential_external_ids"`
	RawJsons              [][]byte             `json:"raw_jsons"`
}

func (q *Queries) UpsertCredentialAuditEventsBulkBySource(ctx context.Context, arg UpsertCredentialAuditEventsBulkBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertCredentialAuditEventsBulkBySource,
		arg.SourceKind,
		arg.SourceName,
		arg.EventExternalIds,
		arg.EventTypes,
		arg.EventTimes,
		arg.ActorKinds,
		arg.ActorExternalIds,
		arg.ActorDisplayNames,
		arg.TargetKinds,
		arg.TargetExternalIds,
		arg.TargetDisplayNames,
		arg.CredentialKinds,
		arg.CredentialExternalIds,
		arg.RawJsons,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: app_users.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAppUsersBySource = `-- name: CountAppUsersBySource :one
SELECT count(*)
FROM app_users
WHERE source_kind = $1
  AND source_name = $2
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

type CountAppUsersBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) CountAppUsersBySource(ctx context.Context, arg CountAppUsersBySourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppUsersBySource, arg.SourceKind, arg.SourceName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAppUsersBySourceAndQueryAndState = `-- name: CountAppUsersBySourceAndQueryAndState :one
SELECT count(*)
FROM app_users au
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
  AND (
    $4::text = ''
    OR ($4::text = 'active' AND lower(COALESCE(NULLIF(trim(au.raw_json->>'status'), ''), '')) = 'active')
    OR ($4::text = 'inactive' AND lower(COALESCE(NULLIF(trim(au.raw_json->>'status'), ''), '')) <> 'active')
  )
`

type CountAppUsersBySourceAndQueryAndStateParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	State      string `json:"state"`
}

func (q *Queries) CountAppUsersBySourceAndQueryAndState(ctx context.Context, arg CountAppUsersBySourceAndQueryAndStateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppUsersBySourceAndQueryAndState,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.State,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAppUsersWithLinkBySourceAndQuery = `-- name: CountAppUsersWithLinkBySourceAndQuery :one
SELECT count(*)
FROM app_users au
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
`

type CountAppUsersWithLinkBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
}

func (q *Queries) CountAppUsersWithLinkBySourceAndQuery(ctx context.Context, arg CountAppUsersWithLinkBySourceAndQueryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppUsersWithLinkBySourceAndQuery, arg.SourceKind, arg.SourceName, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMatchedAppUsersBySource = `-- name: CountMatchedAppUsersBySource :one
SELECT count(*)
FROM app_users au
JOIN identity_links il ON il.app_user_id = au.id
WHERE au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
`

type CountMatchedAppUsersBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) CountMatchedAppUsersBySource(ctx context.Context, arg CountMatchedAppUsersBySourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMatchedAppUsersBySource, arg.SourceKind, arg.SourceName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnmatchedAppUsersBySource = `-- name: CountUnmatchedAppUsersBySource :one
SELECT count(*)
FROM app_users au
LEFT JOIN identity_links il ON il.app_user_id = au.id
WHERE au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND il.id IS NULL
`

type CountUnmatchedAppUsersBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) CountUnmatchedAppUsersBySource(ctx context.Context, arg CountUnmatchedAppUsersBySourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUnmatchedAppUsersBySource, arg.SourceKind, arg.SourceName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnmatchedAppUsersBySourceAndQuery = `-- name: CountUnmatchedAppUsersBySourceAndQuery :one
SELECT count(*)
FROM app_users au
LEFT JOIN identity_links il ON il.app_user_id = au.id
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND il.id IS NULL
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
`

type CountUnmatchedAppUsersBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
}

func (q *Queries) CountUnmatchedAppUsersBySourceAndQuery(ctx context.Context, arg CountUnmatchedAppUsersBySourceAndQueryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUnmatchedAppUsersBySourceAndQuery, arg.SourceKind, arg.SourceName, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAppUser = `-- name: GetAppUser :one
SELECT id, source_kind, source_name, external_id, email, display_name, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
FROM app_users
WHERE id = $1 AND expired_at IS NULL AND last_observed_run_id IS NOT NULL
`

func (q *Queries) GetAppUser(ctx context.Context, id int64) (AppUser, error) {
	row := q.db.QueryRow(ctx, getAppUser, id)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.SourceKind,
		&i.SourceName,
		&i.ExternalID,
		&i.Email,
		&i.DisplayName,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.LastLoginRegion,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
	)
	return i, err
}

const listAppUsersBySource = `-- name: ListAppUsersBySource :many
SELECT id, source_kind, source_name, external_id, email, display_name, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
FROM app_users
WHERE source_kind = $1
  AND source_name = $2
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
ORDER BY id DESC
`

type ListAppUsersBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) ListAppUsersBySource(ctx context.Context, arg ListAppUsersBySourceParams) ([]AppUser, error) {
	rows, err := q.db.Query(ctx, listAppUsersBySource, arg.SourceKind, arg.SourceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUser
	for rows.Next() {
		var i AppUser
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppUsersPageBySourceAndQueryAndState = `-- name: ListAppUsersPageBySourceAndQueryAndState :many
SELECT au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id
FROM app_users au
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
  AND (
    $4::text = ''
    OR ($4::text = 'active' AND lower(COALESCE(NULLIF(trim(au.raw_json->>'status'), ''), '')) = 'active')
    OR ($4::text = 'inactive' AND lower(COALESCE(NULLIF(trim(au.raw_json->>'status'), ''), '')) <> 'active')
  )
ORDER BY au.id DESC
LIMIT $6::int
OFFSET $5::int
`

type ListAppUsersPageBySourceAndQueryAndStateParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	State      string `json:"state"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

func (q *Queries) ListAppUsersPageBySourceAndQueryAndState(ctx context.Context, arg ListAppUsersPageBySourceAndQueryAndStateParams) ([]AppUser, error) {
	rows, err := q.db.Query(ctx, listAppUsersPageBySourceAndQueryAndState,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.State,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUser
	for rows.Next() {
		var i AppUser
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppUsersWithLinkBySource = `-- name: ListAppUsersWithLinkBySource :many
SELECT
  au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id,
  COALESCE(il.idp_user_id, 0) AS idp_user_id
FROM app_users au
LEFT JOIN identity_links il ON il.app_user_id = au.id
WHERE au.source_kind = $1 AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
ORDER BY au.id DESC
`

type ListAppUsersWithLinkBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

type ListAppUsersWithLinkBySourceRow struct {
	ID                int64              `json:"id"`
	SourceKind        string             `json:"source_kind"`
	SourceName        string             `json:"source_name"`
	ExternalID        string             `json:"external_id"`
	Email             string             `json:"email"`
	DisplayName       string             `json:"display_name"`
	RawJson           []byte             `json:"raw_json"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	LastLoginAt       pgtype.Timestamptz `json:"last_login_at"`
	LastLoginIp       string             `json:"last_login_ip"`
	LastLoginRegion   string             `json:"last_login_region"`
	SeenInRunID       pgtype.Int8        `json:"seen_in_run_id"`
	SeenAt            pgtype.Timestamptz `json:"seen_at"`
	LastObservedRunID pgtype.Int8        `json:"last_observed_run_id"`
	LastObservedAt    pgtype.Timestamptz `json:"last_observed_at"`
	ExpiredAt         pgtype.Timestamptz `json:"expired_at"`
	ExpiredRunID      pgtype.Int8        `json:"expired_run_id"`
	IdpUserID         int64              `json:"idp_user_id"`
}

func (q *Queries) ListAppUsersWithLinkBySource(ctx context.Context, arg ListAppUsersWithLinkBySourceParams) ([]ListAppUsersWithLinkBySourceRow, error) {
	rows, err := q.db.Query(ctx, listAppUsersWithLinkBySource, arg.SourceKind, arg.SourceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAppUsersWithLinkBySourceRow
	for rows.Next() {
		var i ListAppUsersWithLinkBySourceRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.IdpUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppUsersWithLinkPageBySourceAndQuery = `-- name: ListAppUsersWithLinkPageBySourceAndQuery :many
SELECT
  au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id,
  COALESCE(il.idp_user_id, 0) AS idp_user_id
FROM app_users au
LEFT JOIN identity_links il ON il.app_user_id = au.id
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
ORDER BY au.id DESC
LIMIT $5::int
OFFSET $4::int
`

type ListAppUsersWithLinkPageBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

type ListAppUsersWithLinkPageBySourceAndQueryRow struct {
	ID                int64              `json:"id"`
	SourceKind        string             `json:"source_kind"`
	SourceName        string             `json:"source_name"`
	ExternalID        string             `json:"external_id"`
	Email             string             `json:"email"`
	DisplayName       string             `json:"display_name"`
	RawJson           []byte             `json:"raw_json"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	LastLoginAt       pgtype.Timestamptz `json:"last_login_at"`
	LastLoginIp       string             `json:"last_login_ip"`
	LastLoginRegion   string             `json:"last_login_region"`
	SeenInRunID       pgtype.Int8        `json:"seen_in_run_id"`
	SeenAt            pgtype.Timestamptz `json:"seen_at"`
	LastObservedRunID pgtype.Int8        `json:"last_observed_run_id"`
	LastObservedAt    pgtype.Timestamptz `json:"last_observed_at"`
	ExpiredAt         pgtype.Timestamptz `json:"expired_at"`
	ExpiredRunID      pgtype.Int8        `json:"expired_run_id"`
	IdpUserID         int64              `json:"idp_user_id"`
}

func (q *Queries) ListAppUsersWithLinkPageBySourceAndQuery(ctx context.Context, arg ListAppUsersWithLinkPageBySourceAndQueryParams) ([]ListAppUsersWithLinkPageBySourceAndQueryRow, error) {
	rows, err := q.db.Query(ctx, listAppUsersWithLinkPageBySourceAndQuery,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAppUsersWithLinkPageBySourceAndQueryRow
	for rows.Next() {
		var i ListAppUsersWithLinkPageBySourceAndQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.IdpUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppUsersWithoutLinkWithEmailBySource = `-- name: ListAppUsersWithoutLinkWithEmailBySource :many
SELECT au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id
FROM app_users au
LEFT JOIN identity_links il ON il.app_user_id = au.id
WHERE au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND il.id IS NULL
  AND au.email <> ''
ORDER BY au.id
`

type ListAppUsersWithoutLinkWithEmailBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) ListAppUsersWithoutLinkWithEmailBySource(ctx context.Context, arg ListAppUsersWithoutLinkWithEmailBySourceParams) ([]AppUser, error) {
	rows, err := q.db.Query(ctx, listAppUsersWithoutLinkWithEmailBySource, arg.SourceKind, arg.SourceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUser
	for rows.Next() {
		var i AppUser
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedAppUsersBySource = `-- name: ListUnmatchedAppUsersBySource :many
SELECT au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id
FROM app_users au
LEFT JOIN identity_links il ON il.app_user_id = au.id
WHERE au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND il.id IS NULL
ORDER BY au.display_name, au.email, au.external_id
`

type ListUnmatchedAppUsersBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) ListUnmatchedAppUsersBySource(ctx context.Context, arg ListUnmatchedAppUsersBySourceParams) ([]AppUser, error) {
	rows, err := q.db.Query(ctx, listUnmatchedAppUsersBySource, arg.SourceKind, arg.SourceName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUser
	for rows.Next() {
		var i AppUser
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedAppUsersPageBySourceAndQuery = `-- name: ListUnmatchedAppUsersPageBySourceAndQuery :many
SELECT au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id
FROM app_users au
LEFT JOIN identity_links il ON il.app_user_id = au.id
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND il.id IS NULL
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
ORDER BY au.display_name, au.email, au.external_id
LIMIT $5::int
OFFSET $4::int
`

type ListUnmatchedAppUsersPageBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

func (q *Queries) ListUnmatchedAppUsersPageBySourceAndQuery(ctx context.Context, arg ListUnmatchedAppUsersPageBySourceAndQueryParams) ([]AppUser, error) {
	rows, err := q.db.Query(ctx, listUnmatchedAppUsersPageBySourceAndQuery,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppUser
	for rows.Next() {
		var i AppUser
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAppUser = `-- name: UpsertAppUser :one
INSERT INTO app_users (source_kind, source_name, external_id, email, display_name, raw_json, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, now(), now())
ON CONFLICT (source_kind, source_name, external_id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name,
  raw_json = EXCLUDED.raw_json,
  last_login_at = COALESCE(EXCLUDED.last_login_at, app_users.last_login_at),
  last_login_ip = CASE WHEN EXCLUDED.last_login_ip <> '' THEN EXCLUDED.last_login_ip ELSE app_users.last_login_ip END,
  last_login_region = CASE WHEN EXCLUDED.last_login_region <> '' THEN EXCLUDED.last_login_region ELSE app_users.last_login_region END,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
RETURNING id, source_kind, source_name, external_id, email, display_name, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
`

type UpsertAppUserParams struct {
	SourceKind      string             `json:"source_kind"`
	SourceName      string             `json:"source_name"`
	ExternalID      string             `json:"external_id"`
	Email           string             `json:"email"`
	DisplayName     string             `json:"display_name"`
	RawJson         []byte             `json:"raw_json"`
	LastLoginAt     pgtype.Timestamptz `json:"last_login_at"`
	LastLoginIp     string             `json:"last_login_ip"`
	LastLoginRegion string             `json:"last_login_region"`
	SeenInRunID     pgtype.Int8        `json:"seen_in_run_id"`
}

func (q *Queries) UpsertAppUser(ctx context.Context, arg UpsertAppUserParams) (AppUser, error) {
	row := q.db.QueryRow(ctx, upsertAppUser,
		arg.SourceKind,
		arg.SourceName,
		arg.ExternalID,
		arg.Email,
		arg.DisplayName,
		arg.RawJson,
		arg.LastLoginAt,
		arg.LastLoginIp,
		arg.LastLoginRegion,
		arg.SeenInRunID,
	)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.SourceKind,
		&i.SourceName,
		&i.ExternalID,
		&i.Email,
		&i.DisplayName,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.LastLoginRegion,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
	)
	return i, err
}

const upsertAppUsersBulkBySource = `-- name: UpsertAppUsersBulkBySource :execrows
WITH input AS (
  SELECT
    i,
    ($4::text[])[i] AS external_id,
    ($5::text[])[i] AS email,
    ($6::text[])[i] AS display_name,
    ($7::jsonb[])[i] AS raw_json,
    ($8::timestamptz[])[i] AS last_login_at,
    ($9::text[])[i] AS last_login_ip,
    ($10::text[])[i] AS last_login_region
  FROM generate_subscripts($4::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (external_id)
    external_id,
    email,
    display_name,
    raw_json,
    last_login_at,
    last_login_ip,
    last_login_region
  FROM input
  ORDER BY external_id, i DESC
)
INSERT INTO app_users (
  source_kind,
  source_name,
  external_id,
  email,
  display_name,
  raw_json,
  last_login_at,
  last_login_ip,
  last_login_region,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  $1::text,
  $2::text,
  input.external_id,
  input.email,
  input.display_name,
  input.raw_json,
  input.last_login_at,
  input.last_login_ip,
  input.last_login_region,
  $3::bigint,
  now(),
  now()
FROM dedup input
ON CONFLICT (source_kind, source_name, external_id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name,
  raw_json = EXCLUDED.raw_json,
  last_login_at = COALESCE(EXCLUDED.last_login_at, app_users.last_login_at),
  last_login_ip = CASE WHEN EXCLUDED.last_login_ip <> '' THEN EXCLUDED.last_login_ip ELSE app_users.last_login_ip END,
  last_login_region = CASE WHEN EXCLUDED.last_login_region <> '' THEN EXCLUDED.last_login_region ELSE app_users.last_login_region END,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertAppUsersBulkBySourceParams struct {
	SourceKind       string               `json:"source_kind"`
	SourceName       string               `json:"source_name"`
	SeenInRunID      int64                `json:"seen_in_run_id"`
	ExternalIds      []string             `json:"external_ids"`
	Emails           []string             `json:"emails"`
	DisplayNames     []string             `json:"display_names"`
	RawJsons         [][]byte             `json:"raw_jsons"`
	LastLoginAts     []pgtype.Timestamptz `json:"last_login_ats"`
	LastLoginIps     []string             `json:"last_login_ips"`
	LastLoginRegions []string             `json:"last_login_regions"`
}

func (q *Queries) UpsertAppUsersBulkBySource(ctx context.Context, arg UpsertAppUsersBulkBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertAppUsersBulkBySource,
		arg.SourceKind,
		arg.SourceName,
		arg.SeenInRunID,
		arg.ExternalIds,
		arg.Emails,
		arg.DisplayNames,
		arg.RawJsons,
		arg.LastLoginAts,
		arg.LastLoginIps,
		arg.LastLoginRegions,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

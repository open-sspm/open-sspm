// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: app_users.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAppUsersBySource = `-- name: CountAppUsersBySource :one
SELECT count(*)
FROM accounts
WHERE source_kind = $1
  AND source_name = $2
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

type CountAppUsersBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) CountAppUsersBySource(ctx context.Context, arg CountAppUsersBySourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppUsersBySource, arg.SourceKind, arg.SourceName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAppUsersBySourceAndQueryAndState = `-- name: CountAppUsersBySourceAndQueryAndState :one
SELECT count(*)
FROM accounts au
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
  AND (
    $4::text = ''
    OR (
      $4::text = 'active'
      AND lower(COALESCE(NULLIF(trim(au.status), ''), NULLIF(trim(au.raw_json->>'status'), ''), '')) = 'active'
    )
    OR (
      $4::text = 'inactive'
      AND lower(COALESCE(NULLIF(trim(au.status), ''), NULLIF(trim(au.raw_json->>'status'), ''), '')) <> 'active'
    )
  )
`

type CountAppUsersBySourceAndQueryAndStateParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	State      string `json:"state"`
}

func (q *Queries) CountAppUsersBySourceAndQueryAndState(ctx context.Context, arg CountAppUsersBySourceAndQueryAndStateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppUsersBySourceAndQueryAndState,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.State,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAppUsersWithLinkBySourceAndQuery = `-- name: CountAppUsersWithLinkBySourceAndQuery :one
SELECT count(*)
FROM accounts au
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
`

type CountAppUsersWithLinkBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
}

func (q *Queries) CountAppUsersWithLinkBySourceAndQuery(ctx context.Context, arg CountAppUsersWithLinkBySourceAndQueryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppUsersWithLinkBySourceAndQuery, arg.SourceKind, arg.SourceName, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMatchedAppUsersBySource = `-- name: CountMatchedAppUsersBySource :one
WITH authoritative_identities AS (
  SELECT DISTINCT ia.identity_id
  FROM identity_accounts ia
  JOIN accounts anchor ON anchor.id = ia.account_id
  JOIN identity_source_settings iss
    ON iss.source_kind = anchor.source_kind
   AND iss.source_name = anchor.source_name
   AND iss.is_authoritative
  WHERE anchor.expired_at IS NULL
    AND anchor.last_observed_run_id IS NOT NULL
)
SELECT count(*)
FROM accounts au
JOIN identity_accounts ia ON ia.account_id = au.id
JOIN authoritative_identities ai ON ai.identity_id = ia.identity_id
WHERE au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
`

type CountMatchedAppUsersBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) CountMatchedAppUsersBySource(ctx context.Context, arg CountMatchedAppUsersBySourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMatchedAppUsersBySource, arg.SourceKind, arg.SourceName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnmatchedAppUsersBySource = `-- name: CountUnmatchedAppUsersBySource :one
WITH authoritative_identities AS (
  SELECT DISTINCT ia.identity_id
  FROM identity_accounts ia
  JOIN accounts anchor ON anchor.id = ia.account_id
  JOIN identity_source_settings iss
    ON iss.source_kind = anchor.source_kind
   AND iss.source_name = anchor.source_name
   AND iss.is_authoritative
  WHERE anchor.expired_at IS NULL
    AND anchor.last_observed_run_id IS NOT NULL
)
SELECT count(*)
FROM accounts au
LEFT JOIN identity_accounts ia ON ia.account_id = au.id
LEFT JOIN authoritative_identities ai ON ai.identity_id = ia.identity_id
WHERE au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    ia.identity_id IS NULL
    OR ai.identity_id IS NULL
  )
`

type CountUnmatchedAppUsersBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) CountUnmatchedAppUsersBySource(ctx context.Context, arg CountUnmatchedAppUsersBySourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUnmatchedAppUsersBySource, arg.SourceKind, arg.SourceName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnmatchedAppUsersBySourceAndQuery = `-- name: CountUnmatchedAppUsersBySourceAndQuery :one
WITH authoritative_identities AS (
  SELECT DISTINCT ia.identity_id
  FROM identity_accounts ia
  JOIN accounts anchor ON anchor.id = ia.account_id
  JOIN identity_source_settings iss
    ON iss.source_kind = anchor.source_kind
   AND iss.source_name = anchor.source_name
   AND iss.is_authoritative
  WHERE anchor.expired_at IS NULL
    AND anchor.last_observed_run_id IS NOT NULL
)
SELECT count(*)
FROM accounts au
LEFT JOIN identity_accounts ia ON ia.account_id = au.id
LEFT JOIN authoritative_identities ai ON ai.identity_id = ia.identity_id
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    ia.identity_id IS NULL
    OR ai.identity_id IS NULL
  )
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
`

type CountUnmatchedAppUsersBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
}

func (q *Queries) CountUnmatchedAppUsersBySourceAndQuery(ctx context.Context, arg CountUnmatchedAppUsersBySourceAndQueryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUnmatchedAppUsersBySourceAndQuery, arg.SourceKind, arg.SourceName, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAppUser = `-- name: GetAppUser :one
SELECT id, source_kind, source_name, external_id, email, display_name, raw_json, created_at, updated_at, last_login_at, last_login_ip, last_login_region, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, status
FROM accounts
WHERE id = $1
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
`

func (q *Queries) GetAppUser(ctx context.Context, id int64) (Account, error) {
	row := q.db.QueryRow(ctx, getAppUser, id)
	var i Account
	err := row.Scan(
		&i.ID,
		&i.SourceKind,
		&i.SourceName,
		&i.ExternalID,
		&i.Email,
		&i.DisplayName,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.LastLoginIp,
		&i.LastLoginRegion,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
		&i.Status,
	)
	return i, err
}

const listAppUsersPageBySourceAndQueryAndState = `-- name: ListAppUsersPageBySourceAndQueryAndState :many
SELECT au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id, au.status
FROM accounts au
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
  AND (
    $4::text = ''
    OR (
      $4::text = 'active'
      AND lower(COALESCE(NULLIF(trim(au.status), ''), NULLIF(trim(au.raw_json->>'status'), ''), '')) = 'active'
    )
    OR (
      $4::text = 'inactive'
      AND lower(COALESCE(NULLIF(trim(au.status), ''), NULLIF(trim(au.raw_json->>'status'), ''), '')) <> 'active'
    )
  )
ORDER BY au.id DESC
LIMIT $6::int
OFFSET $5::int
`

type ListAppUsersPageBySourceAndQueryAndStateParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	State      string `json:"state"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

func (q *Queries) ListAppUsersPageBySourceAndQueryAndState(ctx context.Context, arg ListAppUsersPageBySourceAndQueryAndStateParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listAppUsersPageBySourceAndQueryAndState,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.State,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppUsersWithLinkPageBySourceAndQuery = `-- name: ListAppUsersWithLinkPageBySourceAndQuery :many
SELECT
  au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id, au.status,
  COALESCE(ia.identity_id, 0) AS idp_user_id
FROM accounts au
LEFT JOIN identity_accounts ia ON ia.account_id = au.id
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
ORDER BY au.id DESC
LIMIT $5::int
OFFSET $4::int
`

type ListAppUsersWithLinkPageBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

type ListAppUsersWithLinkPageBySourceAndQueryRow struct {
	ID                int64              `json:"id"`
	SourceKind        string             `json:"source_kind"`
	SourceName        string             `json:"source_name"`
	ExternalID        string             `json:"external_id"`
	Email             string             `json:"email"`
	DisplayName       string             `json:"display_name"`
	RawJson           []byte             `json:"raw_json"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	LastLoginAt       pgtype.Timestamptz `json:"last_login_at"`
	LastLoginIp       string             `json:"last_login_ip"`
	LastLoginRegion   string             `json:"last_login_region"`
	SeenInRunID       pgtype.Int8        `json:"seen_in_run_id"`
	SeenAt            pgtype.Timestamptz `json:"seen_at"`
	LastObservedRunID pgtype.Int8        `json:"last_observed_run_id"`
	LastObservedAt    pgtype.Timestamptz `json:"last_observed_at"`
	ExpiredAt         pgtype.Timestamptz `json:"expired_at"`
	ExpiredRunID      pgtype.Int8        `json:"expired_run_id"`
	Status            string             `json:"status"`
	IdpUserID         int64              `json:"idp_user_id"`
}

func (q *Queries) ListAppUsersWithLinkPageBySourceAndQuery(ctx context.Context, arg ListAppUsersWithLinkPageBySourceAndQueryParams) ([]ListAppUsersWithLinkPageBySourceAndQueryRow, error) {
	rows, err := q.db.Query(ctx, listAppUsersWithLinkPageBySourceAndQuery,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAppUsersWithLinkPageBySourceAndQueryRow
	for rows.Next() {
		var i ListAppUsersWithLinkPageBySourceAndQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
			&i.IdpUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnmatchedAppUsersPageBySourceAndQuery = `-- name: ListUnmatchedAppUsersPageBySourceAndQuery :many
WITH authoritative_identities AS (
  SELECT DISTINCT ia.identity_id
  FROM identity_accounts ia
  JOIN accounts anchor ON anchor.id = ia.account_id
  JOIN identity_source_settings iss
    ON iss.source_kind = anchor.source_kind
   AND iss.source_name = anchor.source_name
   AND iss.is_authoritative
  WHERE anchor.expired_at IS NULL
    AND anchor.last_observed_run_id IS NOT NULL
)
SELECT au.id, au.source_kind, au.source_name, au.external_id, au.email, au.display_name, au.raw_json, au.created_at, au.updated_at, au.last_login_at, au.last_login_ip, au.last_login_region, au.seen_in_run_id, au.seen_at, au.last_observed_run_id, au.last_observed_at, au.expired_at, au.expired_run_id, au.status
FROM accounts au
LEFT JOIN identity_accounts ia ON ia.account_id = au.id
LEFT JOIN authoritative_identities ai ON ai.identity_id = ia.identity_id
WHERE
  au.source_kind = $1
  AND au.source_name = $2
  AND au.expired_at IS NULL
  AND au.last_observed_run_id IS NOT NULL
  AND (
    ia.identity_id IS NULL
    OR ai.identity_id IS NULL
  )
  AND (
    $3::text = ''
    OR au.external_id ILIKE ('%' || $3::text || '%')
    OR au.email ILIKE ('%' || $3::text || '%')
    OR au.display_name ILIKE ('%' || $3::text || '%')
  )
ORDER BY au.display_name, au.email, au.external_id
LIMIT $5::int
OFFSET $4::int
`

type ListUnmatchedAppUsersPageBySourceAndQueryParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

func (q *Queries) ListUnmatchedAppUsersPageBySourceAndQuery(ctx context.Context, arg ListUnmatchedAppUsersPageBySourceAndQueryParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listUnmatchedAppUsersPageBySourceAndQuery,
		arg.SourceKind,
		arg.SourceName,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertAppUsersBulkBySource = `-- name: UpsertAppUsersBulkBySource :execrows
WITH input AS (
  SELECT
    i,
    ($4::text[])[i] AS external_id,
    lower(trim(($5::text[])[i])) AS email,
    ($6::text[])[i] AS display_name,
    ($7::jsonb[])[i] AS raw_json,
    ($8::timestamptz[])[i] AS last_login_at,
    ($9::text[])[i] AS last_login_ip,
    ($10::text[])[i] AS last_login_region
  FROM generate_subscripts($4::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (external_id)
    external_id,
    email,
    display_name,
    raw_json,
    last_login_at,
    last_login_ip,
    last_login_region
  FROM input
  ORDER BY external_id, i DESC
)
INSERT INTO accounts (
  source_kind,
  source_name,
  external_id,
  email,
  display_name,
  status,
  raw_json,
  last_login_at,
  last_login_ip,
  last_login_region,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  $1::text,
  $2::text,
  input.external_id,
  input.email,
  input.display_name,
  COALESCE(NULLIF(trim(input.raw_json ->> 'status'), ''), ''),
  input.raw_json,
  input.last_login_at,
  input.last_login_ip,
  input.last_login_region,
  $3::bigint,
  now(),
  now()
FROM dedup input
ON CONFLICT (source_kind, source_name, external_id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name,
  status = EXCLUDED.status,
  raw_json = EXCLUDED.raw_json,
  last_login_at = COALESCE(EXCLUDED.last_login_at, accounts.last_login_at),
  last_login_ip = CASE WHEN EXCLUDED.last_login_ip <> '' THEN EXCLUDED.last_login_ip ELSE accounts.last_login_ip END,
  last_login_region = CASE WHEN EXCLUDED.last_login_region <> '' THEN EXCLUDED.last_login_region ELSE accounts.last_login_region END,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertAppUsersBulkBySourceParams struct {
	SourceKind       string               `json:"source_kind"`
	SourceName       string               `json:"source_name"`
	SeenInRunID      int64                `json:"seen_in_run_id"`
	ExternalIds      []string             `json:"external_ids"`
	Emails           []string             `json:"emails"`
	DisplayNames     []string             `json:"display_names"`
	RawJsons         [][]byte             `json:"raw_jsons"`
	LastLoginAts     []pgtype.Timestamptz `json:"last_login_ats"`
	LastLoginIps     []string             `json:"last_login_ips"`
	LastLoginRegions []string             `json:"last_login_regions"`
}

func (q *Queries) UpsertAppUsersBulkBySource(ctx context.Context, arg UpsertAppUsersBulkBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertAppUsersBulkBySource,
		arg.SourceKind,
		arg.SourceName,
		arg.SeenInRunID,
		arg.ExternalIds,
		arg.Emails,
		arg.DisplayNames,
		arg.RawJsons,
		arg.LastLoginAts,
		arg.LastLoginIps,
		arg.LastLoginRegions,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertOktaAccountsBulk = `-- name: UpsertOktaAccountsBulk :execrows
WITH input AS (
  SELECT
    i,
    ($3::text[])[i] AS external_id,
    lower(trim(($4::text[])[i])) AS email,
    ($5::text[])[i] AS display_name,
    ($6::text[])[i] AS status,
    ($7::jsonb[])[i] AS raw_json,
    ($8::timestamptz[])[i] AS last_login_at,
    ($9::text[])[i] AS last_login_ip,
    ($10::text[])[i] AS last_login_region
  FROM generate_subscripts($3::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (external_id)
    external_id,
    email,
    display_name,
    status,
    raw_json,
    last_login_at,
    last_login_ip,
    last_login_region
  FROM input
  ORDER BY external_id, i DESC
)
INSERT INTO accounts (
  source_kind,
  source_name,
  external_id,
  email,
  display_name,
  status,
  raw_json,
  last_login_at,
  last_login_ip,
  last_login_region,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  'okta',
  $1::text,
  input.external_id,
  input.email,
  input.display_name,
  input.status,
  input.raw_json,
  input.last_login_at,
  input.last_login_ip,
  input.last_login_region,
  $2::bigint,
  now(),
  now()
FROM dedup input
ON CONFLICT (source_kind, source_name, external_id) DO UPDATE SET
  email = EXCLUDED.email,
  display_name = EXCLUDED.display_name,
  status = EXCLUDED.status,
  raw_json = EXCLUDED.raw_json,
  last_login_at = COALESCE(EXCLUDED.last_login_at, accounts.last_login_at),
  last_login_ip = COALESCE(NULLIF(EXCLUDED.last_login_ip, ''), accounts.last_login_ip),
  last_login_region = COALESCE(NULLIF(EXCLUDED.last_login_region, ''), accounts.last_login_region),
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertOktaAccountsBulkParams struct {
	SourceName       string               `json:"source_name"`
	SeenInRunID      int64                `json:"seen_in_run_id"`
	ExternalIds      []string             `json:"external_ids"`
	Emails           []string             `json:"emails"`
	DisplayNames     []string             `json:"display_names"`
	Statuses         []string             `json:"statuses"`
	RawJsons         [][]byte             `json:"raw_jsons"`
	LastLoginAts     []pgtype.Timestamptz `json:"last_login_ats"`
	LastLoginIps     []string             `json:"last_login_ips"`
	LastLoginRegions []string             `json:"last_login_regions"`
}

func (q *Queries) UpsertOktaAccountsBulk(ctx context.Context, arg UpsertOktaAccountsBulkParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertOktaAccountsBulk,
		arg.SourceName,
		arg.SeenInRunID,
		arg.ExternalIds,
		arg.Emails,
		arg.DisplayNames,
		arg.Statuses,
		arg.RawJsons,
		arg.LastLoginAts,
		arg.LastLoginIps,
		arg.LastLoginRegions,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

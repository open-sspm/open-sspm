// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync_runs.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acquireAdvisoryLock = `-- name: AcquireAdvisoryLock :exec
SELECT pg_advisory_lock($1::bigint)
`

func (q *Queries) AcquireAdvisoryLock(ctx context.Context, dollar_1 int64) error {
	_, err := q.db.Exec(ctx, acquireAdvisoryLock, dollar_1)
	return err
}

const createSyncRun = `-- name: CreateSyncRun :one
INSERT INTO sync_runs (source_kind, source_name, status, started_at)
VALUES ($1, $2, 'running', now())
RETURNING id
`

type CreateSyncRunParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
}

func (q *Queries) CreateSyncRun(ctx context.Context, arg CreateSyncRunParams) (int64, error) {
	row := q.db.QueryRow(ctx, createSyncRun, arg.SourceKind, arg.SourceName)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const failSyncRun = `-- name: FailSyncRun :exec
UPDATE sync_runs
SET status = $2, finished_at = now(), message = $3, error_kind = $4
WHERE id = $1
`

type FailSyncRunParams struct {
	ID        int64  `json:"id"`
	Status    string `json:"status"`
	Message   string `json:"message"`
	ErrorKind string `json:"error_kind"`
}

func (q *Queries) FailSyncRun(ctx context.Context, arg FailSyncRunParams) error {
	_, err := q.db.Exec(ctx, failSyncRun,
		arg.ID,
		arg.Status,
		arg.Message,
		arg.ErrorKind,
	)
	return err
}

const getSyncRunRollupsForSources = `-- name: GetSyncRunRollupsForSources :many
WITH requested AS (
  SELECT k.kind AS source_kind, n.name AS source_name
  FROM unnest($1::text[]) WITH ORDINALITY AS k(kind, ord)
  JOIN unnest($2::text[]) WITH ORDINALITY AS n(name, ord) USING (ord)
),
last_run AS (
  SELECT DISTINCT ON (r.source_kind, r.source_name)
    r.source_kind,
    r.source_name,
    r.id AS last_run_id,
    r.status AS last_run_status,
    r.started_at AS last_run_started_at,
    r.finished_at AS last_run_finished_at,
    r.error_kind AS last_run_error_kind
  FROM sync_runs r
  JOIN requested q
    ON r.source_kind = q.source_kind
   AND r.source_name = q.source_name
  WHERE r.finished_at IS NOT NULL
  ORDER BY r.source_kind, r.source_name, r.finished_at DESC
),
last_success AS (
  SELECT
    r.source_kind,
    r.source_name,
    max(r.finished_at) AS last_success_at
  FROM sync_runs r
  JOIN requested q
    ON r.source_kind = q.source_kind
   AND r.source_name = q.source_name
  WHERE r.finished_at IS NOT NULL
    AND r.status = 'success'
  GROUP BY r.source_kind, r.source_name
),
stats_7d AS (
  SELECT
    r.source_kind,
    r.source_name,
    count(*) FILTER (WHERE r.finished_at >= now() - interval '7 days') AS finished_count_7d,
    count(*) FILTER (WHERE r.finished_at >= now() - interval '7 days' AND r.status = 'success') AS success_count_7d,
    avg(EXTRACT(EPOCH FROM (r.finished_at - r.started_at)) * 1000.0)
      FILTER (WHERE r.finished_at >= now() - interval '7 days' AND r.status = 'success') AS avg_success_duration_ms_7d
  FROM sync_runs r
  JOIN requested q
    ON r.source_kind = q.source_kind
   AND r.source_name = q.source_name
  WHERE r.finished_at IS NOT NULL
    AND r.finished_at >= now() - interval '7 days'
  GROUP BY r.source_kind, r.source_name
)
SELECT
  q.source_kind::text AS source_kind,
  q.source_name::text AS source_name,
  lr.last_run_id,
  lr.last_run_status,
  lr.last_run_started_at,
  lr.last_run_finished_at,
  lr.last_run_error_kind,
  ls.last_success_at::timestamptz AS last_success_at,
  COALESCE(s.finished_count_7d, 0) AS finished_count_7d,
  COALESCE(s.success_count_7d, 0) AS success_count_7d,
  s.avg_success_duration_ms_7d
FROM requested q
LEFT JOIN last_run lr
  ON lr.source_kind = q.source_kind
 AND lr.source_name = q.source_name
LEFT JOIN last_success ls
  ON ls.source_kind = q.source_kind
 AND ls.source_name = q.source_name
LEFT JOIN stats_7d s
  ON s.source_kind = q.source_kind
 AND s.source_name = q.source_name
ORDER BY q.source_kind, q.source_name
`

type GetSyncRunRollupsForSourcesParams struct {
	SourceKinds []string `json:"source_kinds"`
	SourceNames []string `json:"source_names"`
}

type GetSyncRunRollupsForSourcesRow struct {
	SourceKind             string             `json:"source_kind"`
	SourceName             string             `json:"source_name"`
	LastRunID              pgtype.Int8        `json:"last_run_id"`
	LastRunStatus          pgtype.Text        `json:"last_run_status"`
	LastRunStartedAt       pgtype.Timestamptz `json:"last_run_started_at"`
	LastRunFinishedAt      pgtype.Timestamptz `json:"last_run_finished_at"`
	LastRunErrorKind       pgtype.Text        `json:"last_run_error_kind"`
	LastSuccessAt          pgtype.Timestamptz `json:"last_success_at"`
	FinishedCount7d        int64              `json:"finished_count_7d"`
	SuccessCount7d         int64              `json:"success_count_7d"`
	AvgSuccessDurationMs7d pgtype.Float8      `json:"avg_success_duration_ms_7d"`
}

func (q *Queries) GetSyncRunRollupsForSources(ctx context.Context, arg GetSyncRunRollupsForSourcesParams) ([]GetSyncRunRollupsForSourcesRow, error) {
	rows, err := q.db.Query(ctx, getSyncRunRollupsForSources, arg.SourceKinds, arg.SourceNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSyncRunRollupsForSourcesRow
	for rows.Next() {
		var i GetSyncRunRollupsForSourcesRow
		if err := rows.Scan(
			&i.SourceKind,
			&i.SourceName,
			&i.LastRunID,
			&i.LastRunStatus,
			&i.LastRunStartedAt,
			&i.LastRunFinishedAt,
			&i.LastRunErrorKind,
			&i.LastSuccessAt,
			&i.FinishedCount7d,
			&i.SuccessCount7d,
			&i.AvgSuccessDurationMs7d,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLatestSuccessfulSyncFinishedAtForSources = `-- name: ListLatestSuccessfulSyncFinishedAtForSources :many
WITH requested AS (
  SELECT k.kind AS source_kind, n.name AS source_name
  FROM unnest($1::text[]) WITH ORDINALITY AS k(kind, ord)
  JOIN unnest($2::text[]) WITH ORDINALITY AS n(name, ord) USING (ord)
)
SELECT
  q.source_kind::text AS source_kind,
  q.source_name::text AS source_name,
  max(r.finished_at)::timestamptz AS last_success_at
FROM requested q
LEFT JOIN sync_runs r
  ON r.source_kind = q.source_kind
 AND r.source_name = q.source_name
 AND r.status = 'success'
 AND r.finished_at IS NOT NULL
GROUP BY q.source_kind, q.source_name
ORDER BY q.source_kind, q.source_name
`

type ListLatestSuccessfulSyncFinishedAtForSourcesParams struct {
	SourceKinds []string `json:"source_kinds"`
	SourceNames []string `json:"source_names"`
}

type ListLatestSuccessfulSyncFinishedAtForSourcesRow struct {
	SourceKind    string             `json:"source_kind"`
	SourceName    string             `json:"source_name"`
	LastSuccessAt pgtype.Timestamptz `json:"last_success_at"`
}

func (q *Queries) ListLatestSuccessfulSyncFinishedAtForSources(ctx context.Context, arg ListLatestSuccessfulSyncFinishedAtForSourcesParams) ([]ListLatestSuccessfulSyncFinishedAtForSourcesRow, error) {
	rows, err := q.db.Query(ctx, listLatestSuccessfulSyncFinishedAtForSources, arg.SourceKinds, arg.SourceNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLatestSuccessfulSyncFinishedAtForSourcesRow
	for rows.Next() {
		var i ListLatestSuccessfulSyncFinishedAtForSourcesRow
		if err := rows.Scan(&i.SourceKind, &i.SourceName, &i.LastSuccessAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentFinishedSyncRunsBySource = `-- name: ListRecentFinishedSyncRunsBySource :many
SELECT id, status, finished_at, error_kind
FROM sync_runs
WHERE source_kind = $1
  AND source_name = $2
  AND finished_at IS NOT NULL
ORDER BY finished_at DESC
LIMIT $3
`

type ListRecentFinishedSyncRunsBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Limit      int32  `json:"limit"`
}

type ListRecentFinishedSyncRunsBySourceRow struct {
	ID         int64              `json:"id"`
	Status     string             `json:"status"`
	FinishedAt pgtype.Timestamptz `json:"finished_at"`
	ErrorKind  string             `json:"error_kind"`
}

func (q *Queries) ListRecentFinishedSyncRunsBySource(ctx context.Context, arg ListRecentFinishedSyncRunsBySourceParams) ([]ListRecentFinishedSyncRunsBySourceRow, error) {
	rows, err := q.db.Query(ctx, listRecentFinishedSyncRunsBySource, arg.SourceKind, arg.SourceName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentFinishedSyncRunsBySourceRow
	for rows.Next() {
		var i ListRecentFinishedSyncRunsBySourceRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.FinishedAt,
			&i.ErrorKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentFinishedSyncRunsForSources = `-- name: ListRecentFinishedSyncRunsForSources :many
WITH requested AS (
  SELECT k.kind AS source_kind, n.name AS source_name
  FROM unnest($2::text[]) WITH ORDINALITY AS k(kind, ord)
  JOIN unnest($3::text[]) WITH ORDINALITY AS n(name, ord) USING (ord)
),
ranked AS (
  SELECT
    r.source_kind,
    r.source_name,
    r.id,
    r.status,
    r.finished_at,
    r.error_kind,
    row_number() OVER (PARTITION BY r.source_kind, r.source_name ORDER BY r.finished_at DESC) AS rn
  FROM sync_runs r
  JOIN requested q
    ON r.source_kind = q.source_kind
   AND r.source_name = q.source_name
  WHERE r.finished_at IS NOT NULL
)
SELECT source_kind, source_name, id, status, finished_at, error_kind
FROM ranked
WHERE rn <= $1::int
ORDER BY source_kind, source_name, finished_at DESC
`

type ListRecentFinishedSyncRunsForSourcesParams struct {
	LimitRows   int32    `json:"limit_rows"`
	SourceKinds []string `json:"source_kinds"`
	SourceNames []string `json:"source_names"`
}

type ListRecentFinishedSyncRunsForSourcesRow struct {
	SourceKind string             `json:"source_kind"`
	SourceName string             `json:"source_name"`
	ID         int64              `json:"id"`
	Status     string             `json:"status"`
	FinishedAt pgtype.Timestamptz `json:"finished_at"`
	ErrorKind  string             `json:"error_kind"`
}

func (q *Queries) ListRecentFinishedSyncRunsForSources(ctx context.Context, arg ListRecentFinishedSyncRunsForSourcesParams) ([]ListRecentFinishedSyncRunsForSourcesRow, error) {
	rows, err := q.db.Query(ctx, listRecentFinishedSyncRunsForSources, arg.LimitRows, arg.SourceKinds, arg.SourceNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentFinishedSyncRunsForSourcesRow
	for rows.Next() {
		var i ListRecentFinishedSyncRunsForSourcesRow
		if err := rows.Scan(
			&i.SourceKind,
			&i.SourceName,
			&i.ID,
			&i.Status,
			&i.FinishedAt,
			&i.ErrorKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentNonSuccessSyncRunsBySource = `-- name: ListRecentNonSuccessSyncRunsBySource :many
SELECT id, status, finished_at, error_kind, message
FROM sync_runs
WHERE source_kind = $1
  AND source_name = $2
  AND finished_at IS NOT NULL
  AND status <> 'success'
ORDER BY finished_at DESC
LIMIT $3
`

type ListRecentNonSuccessSyncRunsBySourceParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	Limit      int32  `json:"limit"`
}

type ListRecentNonSuccessSyncRunsBySourceRow struct {
	ID         int64              `json:"id"`
	Status     string             `json:"status"`
	FinishedAt pgtype.Timestamptz `json:"finished_at"`
	ErrorKind  string             `json:"error_kind"`
	Message    string             `json:"message"`
}

func (q *Queries) ListRecentNonSuccessSyncRunsBySource(ctx context.Context, arg ListRecentNonSuccessSyncRunsBySourceParams) ([]ListRecentNonSuccessSyncRunsBySourceRow, error) {
	rows, err := q.db.Query(ctx, listRecentNonSuccessSyncRunsBySource, arg.SourceKind, arg.SourceName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentNonSuccessSyncRunsBySourceRow
	for rows.Next() {
		var i ListRecentNonSuccessSyncRunsBySourceRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.FinishedAt,
			&i.ErrorKind,
			&i.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSyncRunSuccess = `-- name: MarkSyncRunSuccess :exec
UPDATE sync_runs
SET status = 'success', finished_at = now(), message = '', stats = $2, error_kind = ''
WHERE id = $1
`

type MarkSyncRunSuccessParams struct {
	ID    int64  `json:"id"`
	Stats []byte `json:"stats"`
}

func (q *Queries) MarkSyncRunSuccess(ctx context.Context, arg MarkSyncRunSuccessParams) error {
	_, err := q.db.Exec(ctx, markSyncRunSuccess, arg.ID, arg.Stats)
	return err
}

const notifyResyncDiscoveryRequested = `-- name: NotifyResyncDiscoveryRequested :exec
SELECT pg_notify('open_sspm_resync_discovery_requested', '')
`

func (q *Queries) NotifyResyncDiscoveryRequested(ctx context.Context) error {
	_, err := q.db.Exec(ctx, notifyResyncDiscoveryRequested)
	return err
}

const notifyResyncRequested = `-- name: NotifyResyncRequested :exec
SELECT pg_notify('open_sspm_resync_requested', '')
`

func (q *Queries) NotifyResyncRequested(ctx context.Context) error {
	_, err := q.db.Exec(ctx, notifyResyncRequested)
	return err
}

const releaseAdvisoryLock = `-- name: ReleaseAdvisoryLock :exec
SELECT pg_advisory_unlock($1::bigint)
`

func (q *Queries) ReleaseAdvisoryLock(ctx context.Context, dollar_1 int64) error {
	_, err := q.db.Exec(ctx, releaseAdvisoryLock, dollar_1)
	return err
}

const tryAcquireAdvisoryLock = `-- name: TryAcquireAdvisoryLock :one
SELECT pg_try_advisory_lock($1::bigint)
`

func (q *Queries) TryAcquireAdvisoryLock(ctx context.Context, dollar_1 int64) (bool, error) {
	row := q.db.QueryRow(ctx, tryAcquireAdvisoryLock, dollar_1)
	var pg_try_advisory_lock bool
	err := row.Scan(&pg_try_advisory_lock)
	return pg_try_advisory_lock, err
}

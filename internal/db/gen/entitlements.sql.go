// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: entitlements.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteEntitlementsForAppUser = `-- name: DeleteEntitlementsForAppUser :exec
DELETE FROM entitlements WHERE app_user_id = $1
`

func (q *Queries) DeleteEntitlementsForAppUser(ctx context.Context, appUserID int64) error {
	_, err := q.db.Exec(ctx, deleteEntitlementsForAppUser, appUserID)
	return err
}

const insertEntitlement = `-- name: InsertEntitlement :one
INSERT INTO entitlements (app_user_id, kind, resource, permission, raw_json, seen_in_run_id, seen_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, now(), now())
ON CONFLICT (app_user_id, kind, resource, permission) DO UPDATE SET
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
RETURNING id, app_user_id, kind, resource, permission, raw_json, created_at, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, updated_at
`

type InsertEntitlementParams struct {
	AppUserID   int64       `json:"app_user_id"`
	Kind        string      `json:"kind"`
	Resource    string      `json:"resource"`
	Permission  string      `json:"permission"`
	RawJson     []byte      `json:"raw_json"`
	SeenInRunID pgtype.Int8 `json:"seen_in_run_id"`
}

func (q *Queries) InsertEntitlement(ctx context.Context, arg InsertEntitlementParams) (Entitlement, error) {
	row := q.db.QueryRow(ctx, insertEntitlement,
		arg.AppUserID,
		arg.Kind,
		arg.Resource,
		arg.Permission,
		arg.RawJson,
		arg.SeenInRunID,
	)
	var i Entitlement
	err := row.Scan(
		&i.ID,
		&i.AppUserID,
		&i.Kind,
		&i.Resource,
		&i.Permission,
		&i.RawJson,
		&i.CreatedAt,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
		&i.UpdatedAt,
	)
	return i, err
}

const listEntitlementResourcesByAppUserIDsAndKind = `-- name: ListEntitlementResourcesByAppUserIDsAndKind :many
SELECT
  app_user_id,
  resource
FROM entitlements
WHERE app_user_id = ANY($1::bigint[])
  AND kind = $2
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
ORDER BY app_user_id, resource
`

type ListEntitlementResourcesByAppUserIDsAndKindParams struct {
	AppUserIds []int64 `json:"app_user_ids"`
	EntKind    string  `json:"ent_kind"`
}

type ListEntitlementResourcesByAppUserIDsAndKindRow struct {
	AppUserID int64  `json:"app_user_id"`
	Resource  string `json:"resource"`
}

func (q *Queries) ListEntitlementResourcesByAppUserIDsAndKind(ctx context.Context, arg ListEntitlementResourcesByAppUserIDsAndKindParams) ([]ListEntitlementResourcesByAppUserIDsAndKindRow, error) {
	rows, err := q.db.Query(ctx, listEntitlementResourcesByAppUserIDsAndKind, arg.AppUserIds, arg.EntKind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEntitlementResourcesByAppUserIDsAndKindRow
	for rows.Next() {
		var i ListEntitlementResourcesByAppUserIDsAndKindRow
		if err := rows.Scan(&i.AppUserID, &i.Resource); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntitlementsForAppUser = `-- name: ListEntitlementsForAppUser :many
SELECT id, app_user_id, kind, resource, permission, raw_json, created_at, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id, updated_at
FROM entitlements
WHERE app_user_id = $1
  AND expired_at IS NULL
  AND last_observed_run_id IS NOT NULL
ORDER BY id
`

func (q *Queries) ListEntitlementsForAppUser(ctx context.Context, appUserID int64) ([]Entitlement, error) {
	rows, err := q.db.Query(ctx, listEntitlementsForAppUser, appUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entitlement
	for rows.Next() {
		var i Entitlement
		if err := rows.Scan(
			&i.ID,
			&i.AppUserID,
			&i.Kind,
			&i.Resource,
			&i.Permission,
			&i.RawJson,
			&i.CreatedAt,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEntitlementsBulkBySource = `-- name: UpsertEntitlementsBulkBySource :execrows
WITH input AS (
  SELECT
    i,
    ($4::text[])[i] AS app_user_external_id,
    ($5::text[])[i] AS kind,
    ($6::text[])[i] AS resource,
    ($7::text[])[i] AS permission,
    ($8::jsonb[])[i] AS raw_json
  FROM generate_subscripts($4::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (app_user_external_id, kind, resource, permission)
    app_user_external_id,
    kind,
    resource,
    permission,
    raw_json
  FROM input
  ORDER BY app_user_external_id, kind, resource, permission, i DESC
)
INSERT INTO entitlements (
  app_user_id,
  kind,
  resource,
  permission,
  raw_json,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  au.id,
  input.kind,
  input.resource,
  input.permission,
  input.raw_json,
  $1::bigint,
  now(),
  now()
FROM dedup input
JOIN app_users au
  ON au.source_kind = $2::text
  AND au.source_name = $3::text
  AND au.external_id = input.app_user_external_id
ON CONFLICT (app_user_id, kind, resource, permission) DO UPDATE SET
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertEntitlementsBulkBySourceParams struct {
	SeenInRunID        int64    `json:"seen_in_run_id"`
	SourceKind         string   `json:"source_kind"`
	SourceName         string   `json:"source_name"`
	AppUserExternalIds []string `json:"app_user_external_ids"`
	Kinds              []string `json:"kinds"`
	Resources          []string `json:"resources"`
	Permissions        []string `json:"permissions"`
	RawJsons           [][]byte `json:"raw_jsons"`
}

func (q *Queries) UpsertEntitlementsBulkBySource(ctx context.Context, arg UpsertEntitlementsBulkBySourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertEntitlementsBulkBySource,
		arg.SeenInRunID,
		arg.SourceKind,
		arg.SourceName,
		arg.AppUserExternalIds,
		arg.Kinds,
		arg.Resources,
		arg.Permissions,
		arg.RawJsons,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

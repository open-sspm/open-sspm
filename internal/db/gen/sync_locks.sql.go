// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sync_locks.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const releaseSyncLockLease = `-- name: ReleaseSyncLockLease :exec
DELETE FROM sync_locks
WHERE
  scope_kind = $1
  AND scope_name = $2
  AND holder_token = $3
`

type ReleaseSyncLockLeaseParams struct {
	ScopeKind   string      `json:"scope_kind"`
	ScopeName   string      `json:"scope_name"`
	HolderToken pgtype.UUID `json:"holder_token"`
}

func (q *Queries) ReleaseSyncLockLease(ctx context.Context, arg ReleaseSyncLockLeaseParams) error {
	_, err := q.db.Exec(ctx, releaseSyncLockLease, arg.ScopeKind, arg.ScopeName, arg.HolderToken)
	return err
}

const renewSyncLockLease = `-- name: RenewSyncLockLease :one
UPDATE sync_locks
SET
  lease_expires_at = clock_timestamp() + ($1::bigint * interval '1 second'),
  heartbeat_at = clock_timestamp()
WHERE
  scope_kind = $2
  AND scope_name = $3
  AND holder_token = $4
RETURNING lease_expires_at
`

type RenewSyncLockLeaseParams struct {
	LeaseSeconds int64       `json:"lease_seconds"`
	ScopeKind    string      `json:"scope_kind"`
	ScopeName    string      `json:"scope_name"`
	HolderToken  pgtype.UUID `json:"holder_token"`
}

func (q *Queries) RenewSyncLockLease(ctx context.Context, arg RenewSyncLockLeaseParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, renewSyncLockLease,
		arg.LeaseSeconds,
		arg.ScopeKind,
		arg.ScopeName,
		arg.HolderToken,
	)
	var lease_expires_at pgtype.Timestamptz
	err := row.Scan(&lease_expires_at)
	return lease_expires_at, err
}

const tryAcquireSyncLockLease = `-- name: TryAcquireSyncLockLease :one

INSERT INTO sync_locks (
  scope_kind,
  scope_name,
  holder_instance_id,
  holder_token,
  acquired_at,
  lease_expires_at,
  heartbeat_at
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  clock_timestamp(),
  clock_timestamp() + ($5::bigint * interval '1 second'),
  clock_timestamp()
)
ON CONFLICT (scope_kind, scope_name) DO UPDATE
SET
  holder_instance_id = EXCLUDED.holder_instance_id,
  holder_token = EXCLUDED.holder_token,
  acquired_at = clock_timestamp(),
  lease_expires_at = EXCLUDED.lease_expires_at,
  heartbeat_at = EXCLUDED.heartbeat_at
WHERE
  sync_locks.lease_expires_at < clock_timestamp()
  OR sync_locks.holder_token = EXCLUDED.holder_token
RETURNING
  scope_kind,
  scope_name,
  holder_instance_id,
  holder_token,
  acquired_at,
  lease_expires_at,
  heartbeat_at
`

type TryAcquireSyncLockLeaseParams struct {
	ScopeKind        string      `json:"scope_kind"`
	ScopeName        string      `json:"scope_name"`
	HolderInstanceID string      `json:"holder_instance_id"`
	HolderToken      pgtype.UUID `json:"holder_token"`
	LeaseSeconds     int64       `json:"lease_seconds"`
}

// Lease-based sync locks (no session-pinned connections).
func (q *Queries) TryAcquireSyncLockLease(ctx context.Context, arg TryAcquireSyncLockLeaseParams) (SyncLock, error) {
	row := q.db.QueryRow(ctx, tryAcquireSyncLockLease,
		arg.ScopeKind,
		arg.ScopeName,
		arg.HolderInstanceID,
		arg.HolderToken,
		arg.LeaseSeconds,
	)
	var i SyncLock
	err := row.Scan(
		&i.ScopeKind,
		&i.ScopeName,
		&i.HolderInstanceID,
		&i.HolderToken,
		&i.AcquiredAt,
		&i.LeaseExpiresAt,
		&i.HeartbeatAt,
	)
	return i, err
}

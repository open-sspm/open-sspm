// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: identity_accounts.sql

package gen

import (
	"context"
)

const countUnlinkedAccounts = `-- name: CountUnlinkedAccounts :one
SELECT count(*)
FROM accounts a
LEFT JOIN identity_accounts ia ON ia.account_id = a.id
WHERE ia.id IS NULL
  AND a.expired_at IS NULL
  AND a.last_observed_run_id IS NOT NULL
`

func (q *Queries) CountUnlinkedAccounts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUnlinkedAccounts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getIdentityAccountLinkByAccountID = `-- name: GetIdentityAccountLinkByAccountID :one
SELECT id, identity_id, account_id, link_reason, confidence, created_at, updated_at
FROM identity_accounts
WHERE account_id = $1
`

func (q *Queries) GetIdentityAccountLinkByAccountID(ctx context.Context, accountID int64) (IdentityAccount, error) {
	row := q.db.QueryRow(ctx, getIdentityAccountLinkByAccountID, accountID)
	var i IdentityAccount
	err := row.Scan(
		&i.ID,
		&i.IdentityID,
		&i.AccountID,
		&i.LinkReason,
		&i.Confidence,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIdentityBySourceAndExternalID = `-- name: GetIdentityBySourceAndExternalID :one
SELECT i.id, i.kind, i.display_name, i.primary_email, i.created_at, i.updated_at
FROM identities i
JOIN identity_accounts ia ON ia.identity_id = i.id
JOIN accounts a ON a.id = ia.account_id
WHERE lower(trim(a.source_kind)) = lower(trim($1::text))
  AND lower(trim(a.source_name)) = lower(trim($2::text))
  AND lower(trim(a.external_id)) = lower(trim($3::text))
  AND a.expired_at IS NULL
  AND a.last_observed_run_id IS NOT NULL
ORDER BY i.id ASC
LIMIT 1
`

type GetIdentityBySourceAndExternalIDParams struct {
	SourceKind string `json:"source_kind"`
	SourceName string `json:"source_name"`
	ExternalID string `json:"external_id"`
}

func (q *Queries) GetIdentityBySourceAndExternalID(ctx context.Context, arg GetIdentityBySourceAndExternalIDParams) (Identity, error) {
	row := q.db.QueryRow(ctx, getIdentityBySourceAndExternalID, arg.SourceKind, arg.SourceName, arg.ExternalID)
	var i Identity
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.DisplayName,
		&i.PrimaryEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listIdentityAccountAttributes = `-- name: ListIdentityAccountAttributes :many
SELECT
  ia.identity_id,
  a.id AS account_id,
  a.source_kind,
  a.source_name,
  a.email,
  a.display_name
FROM identity_accounts ia
JOIN accounts a ON a.id = ia.account_id
WHERE a.expired_at IS NULL
  AND a.last_observed_run_id IS NOT NULL
ORDER BY ia.identity_id, a.id
`

type ListIdentityAccountAttributesRow struct {
	IdentityID  int64  `json:"identity_id"`
	AccountID   int64  `json:"account_id"`
	SourceKind  string `json:"source_kind"`
	SourceName  string `json:"source_name"`
	Email       string `json:"email"`
	DisplayName string `json:"display_name"`
}

func (q *Queries) ListIdentityAccountAttributes(ctx context.Context) ([]ListIdentityAccountAttributesRow, error) {
	rows, err := q.db.Query(ctx, listIdentityAccountAttributes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListIdentityAccountAttributesRow
	for rows.Next() {
		var i ListIdentityAccountAttributesRow
		if err := rows.Scan(
			&i.IdentityID,
			&i.AccountID,
			&i.SourceKind,
			&i.SourceName,
			&i.Email,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkedAccountsForIdentity = `-- name: ListLinkedAccountsForIdentity :many
SELECT a.id, a.source_kind, a.source_name, a.external_id, a.email, a.display_name, a.raw_json, a.created_at, a.updated_at, a.last_login_at, a.last_login_ip, a.last_login_region, a.seen_in_run_id, a.seen_at, a.last_observed_run_id, a.last_observed_at, a.expired_at, a.expired_run_id, a.status
FROM accounts a
JOIN identity_accounts ia ON ia.account_id = a.id
WHERE ia.identity_id = $1
  AND a.expired_at IS NULL
  AND a.last_observed_run_id IS NOT NULL
ORDER BY a.source_kind, a.source_name, a.external_id
`

func (q *Queries) ListLinkedAccountsForIdentity(ctx context.Context, identityID int64) ([]Account, error) {
	rows, err := q.db.Query(ctx, listLinkedAccountsForIdentity, identityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnlinkedAccountsPage = `-- name: ListUnlinkedAccountsPage :many
SELECT a.id, a.source_kind, a.source_name, a.external_id, a.email, a.display_name, a.raw_json, a.created_at, a.updated_at, a.last_login_at, a.last_login_ip, a.last_login_region, a.seen_in_run_id, a.seen_at, a.last_observed_run_id, a.last_observed_at, a.expired_at, a.expired_run_id, a.status
FROM accounts a
LEFT JOIN identity_accounts ia ON ia.account_id = a.id
WHERE ia.id IS NULL
  AND a.expired_at IS NULL
  AND a.last_observed_run_id IS NOT NULL
ORDER BY a.id ASC
LIMIT $2::int
OFFSET $1::int
`

type ListUnlinkedAccountsPageParams struct {
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

func (q *Queries) ListUnlinkedAccountsPage(ctx context.Context, arg ListUnlinkedAccountsPageParams) ([]Account, error) {
	rows, err := q.db.Query(ctx, listUnlinkedAccountsPage, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Account
	for rows.Next() {
		var i Account
		if err := rows.Scan(
			&i.ID,
			&i.SourceKind,
			&i.SourceName,
			&i.ExternalID,
			&i.Email,
			&i.DisplayName,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.LastLoginIp,
			&i.LastLoginRegion,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertIdentityAccountLink = `-- name: UpsertIdentityAccountLink :one
INSERT INTO identity_accounts (identity_id, account_id, link_reason, confidence, updated_at)
VALUES (
  $1::bigint,
  $2::bigint,
  $3::text,
  $4::real,
  now()
)
ON CONFLICT (account_id) DO UPDATE SET
  identity_id = EXCLUDED.identity_id,
  link_reason = EXCLUDED.link_reason,
  confidence = EXCLUDED.confidence,
  updated_at = EXCLUDED.updated_at
RETURNING id, identity_id, account_id, link_reason, confidence, created_at, updated_at
`

type UpsertIdentityAccountLinkParams struct {
	IdentityID int64   `json:"identity_id"`
	AccountID  int64   `json:"account_id"`
	LinkReason string  `json:"link_reason"`
	Confidence float32 `json:"confidence"`
}

func (q *Queries) UpsertIdentityAccountLink(ctx context.Context, arg UpsertIdentityAccountLinkParams) (IdentityAccount, error) {
	row := q.db.QueryRow(ctx, upsertIdentityAccountLink,
		arg.IdentityID,
		arg.AccountID,
		arg.LinkReason,
		arg.Confidence,
	)
	var i IdentityAccount
	err := row.Scan(
		&i.ID,
		&i.IdentityID,
		&i.AccountID,
		&i.LinkReason,
		&i.Confidence,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

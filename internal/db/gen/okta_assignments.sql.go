// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: okta_assignments.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countConnectedOktaApps = `-- name: CountConnectedOktaApps :one
SELECT count(*)
FROM okta_apps oa
JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE oa.expired_at IS NULL AND oa.last_observed_run_id IS NOT NULL
`

func (q *Queries) CountConnectedOktaApps(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countConnectedOktaApps)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOktaAppUserAssignmentsByQuery = `-- name: CountOktaAppUserAssignmentsByQuery :one
SELECT count(*)
FROM okta_user_app_assignments ouaa
JOIN accounts u ON u.id = ouaa.okta_user_account_id
WHERE
  ouaa.okta_app_id = $1
  AND ouaa.expired_at IS NULL
  AND ouaa.last_observed_run_id IS NOT NULL
  AND u.expired_at IS NULL
  AND u.last_observed_run_id IS NOT NULL
  AND (
    $2::text = ''
    OR ($2::text = 'active' AND u.status = 'ACTIVE')
    OR ($2::text = 'inactive' AND u.status <> 'ACTIVE')
  )
  AND (
    $3::text = ''
    OR u.email ILIKE ('%' || $3::text || '%')
    OR u.display_name ILIKE ('%' || $3::text || '%')
    OR u.external_id ILIKE ('%' || $3::text || '%')
  )
`

type CountOktaAppUserAssignmentsByQueryParams struct {
	OktaAppID int64  `json:"okta_app_id"`
	State     string `json:"state"`
	Query     string `json:"query"`
}

func (q *Queries) CountOktaAppUserAssignmentsByQuery(ctx context.Context, arg CountOktaAppUserAssignmentsByQueryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOktaAppUserAssignmentsByQuery, arg.OktaAppID, arg.State, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOktaApps = `-- name: CountOktaApps :one
SELECT count(*)
FROM okta_apps
WHERE expired_at IS NULL AND last_observed_run_id IS NOT NULL
`

func (q *Queries) CountOktaApps(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOktaApps)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOktaAppsByQuery = `-- name: CountOktaAppsByQuery :one
SELECT count(*)
FROM okta_apps oa
WHERE
  oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
  AND (
    $1::text = ''
    OR oa.label ILIKE ('%' || $1::text || '%')
    OR oa.name ILIKE ('%' || $1::text || '%')
    OR oa.external_id ILIKE ('%' || $1::text || '%')
  )
`

func (q *Queries) CountOktaAppsByQuery(ctx context.Context, query string) (int64, error) {
	row := q.db.QueryRow(ctx, countOktaAppsByQuery, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOktaAppByExternalIDWithIntegration = `-- name: GetOktaAppByExternalIDWithIntegration :one
SELECT
  oa.id,
  oa.external_id,
  oa.label,
  oa.name,
  oa.status,
  oa.sign_on_mode,
  oa.raw_json,
  oa.created_at,
  oa.updated_at,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_apps oa
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE oa.external_id = $1
  AND oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
`

type GetOktaAppByExternalIDWithIntegrationRow struct {
	ID              int64              `json:"id"`
	ExternalID      string             `json:"external_id"`
	Label           string             `json:"label"`
	Name            string             `json:"name"`
	Status          string             `json:"status"`
	SignOnMode      string             `json:"sign_on_mode"`
	RawJson         []byte             `json:"raw_json"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	IntegrationKind string             `json:"integration_kind"`
}

func (q *Queries) GetOktaAppByExternalIDWithIntegration(ctx context.Context, externalID string) (GetOktaAppByExternalIDWithIntegrationRow, error) {
	row := q.db.QueryRow(ctx, getOktaAppByExternalIDWithIntegration, externalID)
	var i GetOktaAppByExternalIDWithIntegrationRow
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Label,
		&i.Name,
		&i.Status,
		&i.SignOnMode,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IntegrationKind,
	)
	return i, err
}

const getOktaUserAppAssignmentForIdpUserByOktaAppExternalID = `-- name: GetOktaUserAppAssignmentForIdpUserByOktaAppExternalID :one
SELECT
  ouaa.okta_user_account_id AS idp_user_id,
  ouaa.okta_app_id,
  ouaa.scope,
  ouaa.profile_json,
  ouaa.raw_json AS assignment_raw_json,
  oa.external_id AS okta_app_external_id,
  oa.label AS app_label,
  oa.name AS app_name,
  oa.status AS app_status,
  oa.sign_on_mode AS app_sign_on_mode,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_user_app_assignments ouaa
JOIN okta_apps oa ON oa.id = ouaa.okta_app_id
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE
  ouaa.okta_user_account_id = $1
  AND ouaa.expired_at IS NULL
  AND ouaa.last_observed_run_id IS NOT NULL
  AND oa.external_id = $2
  AND oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
LIMIT 1
`

type GetOktaUserAppAssignmentForIdpUserByOktaAppExternalIDParams struct {
	IdpUserID         int64  `json:"idp_user_id"`
	OktaAppExternalID string `json:"okta_app_external_id"`
}

type GetOktaUserAppAssignmentForIdpUserByOktaAppExternalIDRow struct {
	IdpUserID         int64  `json:"idp_user_id"`
	OktaAppID         int64  `json:"okta_app_id"`
	Scope             string `json:"scope"`
	ProfileJson       []byte `json:"profile_json"`
	AssignmentRawJson []byte `json:"assignment_raw_json"`
	OktaAppExternalID string `json:"okta_app_external_id"`
	AppLabel          string `json:"app_label"`
	AppName           string `json:"app_name"`
	AppStatus         string `json:"app_status"`
	AppSignOnMode     string `json:"app_sign_on_mode"`
	IntegrationKind   string `json:"integration_kind"`
}

func (q *Queries) GetOktaUserAppAssignmentForIdpUserByOktaAppExternalID(ctx context.Context, arg GetOktaUserAppAssignmentForIdpUserByOktaAppExternalIDParams) (GetOktaUserAppAssignmentForIdpUserByOktaAppExternalIDRow, error) {
	row := q.db.QueryRow(ctx, getOktaUserAppAssignmentForIdpUserByOktaAppExternalID, arg.IdpUserID, arg.OktaAppExternalID)
	var i GetOktaUserAppAssignmentForIdpUserByOktaAppExternalIDRow
	err := row.Scan(
		&i.IdpUserID,
		&i.OktaAppID,
		&i.Scope,
		&i.ProfileJson,
		&i.AssignmentRawJson,
		&i.OktaAppExternalID,
		&i.AppLabel,
		&i.AppName,
		&i.AppStatus,
		&i.AppSignOnMode,
		&i.IntegrationKind,
	)
	return i, err
}

const listOktaAppGrantingGroupsForIdpUserByOktaAppExternalID = `-- name: ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalID :many
SELECT
  og.name AS okta_group_name,
  og.external_id AS okta_group_external_id
FROM okta_user_groups ug
JOIN okta_app_group_assignments oga ON oga.okta_group_id = ug.okta_group_id
JOIN okta_groups og ON og.id = ug.okta_group_id
JOIN okta_apps oa ON oa.id = oga.okta_app_id
WHERE
  ug.okta_user_account_id = $1
  AND ug.expired_at IS NULL
  AND ug.last_observed_run_id IS NOT NULL
  AND oga.expired_at IS NULL
  AND oga.last_observed_run_id IS NOT NULL
  AND og.expired_at IS NULL
  AND og.last_observed_run_id IS NOT NULL
  AND oa.external_id = $2
  AND oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
ORDER BY og.name, og.external_id
`

type ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDParams struct {
	IdpUserID         int64  `json:"idp_user_id"`
	OktaAppExternalID string `json:"okta_app_external_id"`
}

type ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDRow struct {
	OktaGroupName       string `json:"okta_group_name"`
	OktaGroupExternalID string `json:"okta_group_external_id"`
}

func (q *Queries) ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalID(ctx context.Context, arg ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDParams) ([]ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppGrantingGroupsForIdpUserByOktaAppExternalID, arg.IdpUserID, arg.OktaAppExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDRow
	for rows.Next() {
		var i ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDRow
		if err := rows.Scan(&i.OktaGroupName, &i.OktaGroupExternalID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppGrantingGroupsForIdpUsers = `-- name: ListOktaAppGrantingGroupsForIdpUsers :many
SELECT
  ug.okta_user_account_id AS idp_user_id,
  og.name AS okta_group_name,
  og.external_id AS okta_group_external_id
FROM okta_user_groups ug
JOIN okta_app_group_assignments oga ON oga.okta_group_id = ug.okta_group_id
JOIN okta_groups og ON og.id = ug.okta_group_id
WHERE
  oga.okta_app_id = $1
  AND ug.expired_at IS NULL
  AND ug.last_observed_run_id IS NOT NULL
  AND oga.expired_at IS NULL
  AND oga.last_observed_run_id IS NOT NULL
  AND og.expired_at IS NULL
  AND og.last_observed_run_id IS NOT NULL
  AND ug.okta_user_account_id = ANY($2::bigint[])
ORDER BY ug.okta_user_account_id, og.name, og.external_id
`

type ListOktaAppGrantingGroupsForIdpUsersParams struct {
	OktaAppID  int64   `json:"okta_app_id"`
	IdpUserIds []int64 `json:"idp_user_ids"`
}

type ListOktaAppGrantingGroupsForIdpUsersRow struct {
	IdpUserID           int64  `json:"idp_user_id"`
	OktaGroupName       string `json:"okta_group_name"`
	OktaGroupExternalID string `json:"okta_group_external_id"`
}

func (q *Queries) ListOktaAppGrantingGroupsForIdpUsers(ctx context.Context, arg ListOktaAppGrantingGroupsForIdpUsersParams) ([]ListOktaAppGrantingGroupsForIdpUsersRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppGrantingGroupsForIdpUsers, arg.OktaAppID, arg.IdpUserIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppGrantingGroupsForIdpUsersRow
	for rows.Next() {
		var i ListOktaAppGrantingGroupsForIdpUsersRow
		if err := rows.Scan(&i.IdpUserID, &i.OktaGroupName, &i.OktaGroupExternalID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppGroupAssignmentsByAppIDs = `-- name: ListOktaAppGroupAssignmentsByAppIDs :many
SELECT
  oga.okta_app_id,
  oga.okta_group_id,
  og.name AS okta_group_name,
  og.external_id AS okta_group_external_id
FROM okta_app_group_assignments oga
LEFT JOIN okta_groups og
  ON og.id = oga.okta_group_id
  AND og.expired_at IS NULL
  AND og.last_observed_run_id IS NOT NULL
WHERE oga.okta_app_id = ANY($1::bigint[])
  AND oga.expired_at IS NULL
  AND oga.last_observed_run_id IS NOT NULL
ORDER BY oga.okta_app_id, og.name, og.external_id
`

type ListOktaAppGroupAssignmentsByAppIDsRow struct {
	OktaAppID           int64       `json:"okta_app_id"`
	OktaGroupID         int64       `json:"okta_group_id"`
	OktaGroupName       pgtype.Text `json:"okta_group_name"`
	OktaGroupExternalID pgtype.Text `json:"okta_group_external_id"`
}

func (q *Queries) ListOktaAppGroupAssignmentsByAppIDs(ctx context.Context, dollar_1 []int64) ([]ListOktaAppGroupAssignmentsByAppIDsRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppGroupAssignmentsByAppIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppGroupAssignmentsByAppIDsRow
	for rows.Next() {
		var i ListOktaAppGroupAssignmentsByAppIDsRow
		if err := rows.Scan(
			&i.OktaAppID,
			&i.OktaGroupID,
			&i.OktaGroupName,
			&i.OktaGroupExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppUserAssignmentsPageByQuery = `-- name: ListOktaAppUserAssignmentsPageByQuery :many
SELECT
  u.id AS idp_user_id,
  u.external_id AS idp_user_external_id,
  u.email AS idp_user_email,
  u.display_name AS idp_user_display_name,
  u.status AS idp_user_status,
  ouaa.scope,
  ouaa.profile_json
FROM okta_user_app_assignments ouaa
JOIN accounts u ON u.id = ouaa.okta_user_account_id
WHERE
  ouaa.okta_app_id = $1
  AND ouaa.expired_at IS NULL
  AND ouaa.last_observed_run_id IS NOT NULL
  AND u.expired_at IS NULL
  AND u.last_observed_run_id IS NOT NULL
  AND (
    $2::text = ''
    OR ($2::text = 'active' AND u.status = 'ACTIVE')
    OR ($2::text = 'inactive' AND u.status <> 'ACTIVE')
  )
  AND (
    $3::text = ''
    OR u.email ILIKE ('%' || $3::text || '%')
    OR u.display_name ILIKE ('%' || $3::text || '%')
    OR u.external_id ILIKE ('%' || $3::text || '%')
  )
ORDER BY (u.display_name = ''), u.display_name, u.email, u.external_id
LIMIT $5::int
OFFSET $4::int
`

type ListOktaAppUserAssignmentsPageByQueryParams struct {
	OktaAppID  int64  `json:"okta_app_id"`
	State      string `json:"state"`
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

type ListOktaAppUserAssignmentsPageByQueryRow struct {
	IdpUserID          int64  `json:"idp_user_id"`
	IdpUserExternalID  string `json:"idp_user_external_id"`
	IdpUserEmail       string `json:"idp_user_email"`
	IdpUserDisplayName string `json:"idp_user_display_name"`
	IdpUserStatus      string `json:"idp_user_status"`
	Scope              string `json:"scope"`
	ProfileJson        []byte `json:"profile_json"`
}

func (q *Queries) ListOktaAppUserAssignmentsPageByQuery(ctx context.Context, arg ListOktaAppUserAssignmentsPageByQueryParams) ([]ListOktaAppUserAssignmentsPageByQueryRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppUserAssignmentsPageByQuery,
		arg.OktaAppID,
		arg.State,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppUserAssignmentsPageByQueryRow
	for rows.Next() {
		var i ListOktaAppUserAssignmentsPageByQueryRow
		if err := rows.Scan(
			&i.IdpUserID,
			&i.IdpUserExternalID,
			&i.IdpUserEmail,
			&i.IdpUserDisplayName,
			&i.IdpUserStatus,
			&i.Scope,
			&i.ProfileJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppsForCommand = `-- name: ListOktaAppsForCommand :many
SELECT
  oa.external_id,
  oa.label,
  oa.name,
  oa.status,
  oa.sign_on_mode,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_apps oa
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE oa.expired_at IS NULL AND oa.last_observed_run_id IS NOT NULL
ORDER BY (m.integration_kind IS NULL), oa.label, oa.name, oa.external_id
LIMIT 200
`

type ListOktaAppsForCommandRow struct {
	ExternalID      string `json:"external_id"`
	Label           string `json:"label"`
	Name            string `json:"name"`
	Status          string `json:"status"`
	SignOnMode      string `json:"sign_on_mode"`
	IntegrationKind string `json:"integration_kind"`
}

func (q *Queries) ListOktaAppsForCommand(ctx context.Context) ([]ListOktaAppsForCommandRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppsForCommand)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppsForCommandRow
	for rows.Next() {
		var i ListOktaAppsForCommandRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.Label,
			&i.Name,
			&i.Status,
			&i.SignOnMode,
			&i.IntegrationKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppsPage = `-- name: ListOktaAppsPage :many
SELECT
  oa.external_id,
  oa.label,
  oa.name,
  oa.status,
  oa.sign_on_mode,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_apps oa
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE oa.expired_at IS NULL AND oa.last_observed_run_id IS NOT NULL
ORDER BY (m.integration_kind IS NULL), oa.label, oa.name, oa.external_id
LIMIT $2::int
OFFSET $1::int
`

type ListOktaAppsPageParams struct {
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

type ListOktaAppsPageRow struct {
	ExternalID      string `json:"external_id"`
	Label           string `json:"label"`
	Name            string `json:"name"`
	Status          string `json:"status"`
	SignOnMode      string `json:"sign_on_mode"`
	IntegrationKind string `json:"integration_kind"`
}

func (q *Queries) ListOktaAppsPage(ctx context.Context, arg ListOktaAppsPageParams) ([]ListOktaAppsPageRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppsPage, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppsPageRow
	for rows.Next() {
		var i ListOktaAppsPageRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.Label,
			&i.Name,
			&i.Status,
			&i.SignOnMode,
			&i.IntegrationKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppsPageByQuery = `-- name: ListOktaAppsPageByQuery :many
SELECT
  oa.external_id,
  oa.label,
  oa.name,
  oa.status,
  oa.sign_on_mode,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_apps oa
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE
  oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
  AND (
    $1::text = ''
    OR oa.label ILIKE ('%' || $1::text || '%')
    OR oa.name ILIKE ('%' || $1::text || '%')
    OR oa.external_id ILIKE ('%' || $1::text || '%')
  )
ORDER BY (m.integration_kind IS NULL), oa.label, oa.name, oa.external_id
LIMIT $3::int
OFFSET $2::int
`

type ListOktaAppsPageByQueryParams struct {
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

type ListOktaAppsPageByQueryRow struct {
	ExternalID      string `json:"external_id"`
	Label           string `json:"label"`
	Name            string `json:"name"`
	Status          string `json:"status"`
	SignOnMode      string `json:"sign_on_mode"`
	IntegrationKind string `json:"integration_kind"`
}

func (q *Queries) ListOktaAppsPageByQuery(ctx context.Context, arg ListOktaAppsPageByQueryParams) ([]ListOktaAppsPageByQueryRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppsPageByQuery, arg.Query, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppsPageByQueryRow
	for rows.Next() {
		var i ListOktaAppsPageByQueryRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.Label,
			&i.Name,
			&i.Status,
			&i.SignOnMode,
			&i.IntegrationKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaGroupsForIdpUser = `-- name: ListOktaGroupsForIdpUser :many
SELECT og.id, og.external_id, og.name, og.type, og.raw_json, og.created_at, og.updated_at, og.seen_in_run_id, og.seen_at, og.last_observed_run_id, og.last_observed_at, og.expired_at, og.expired_run_id
FROM okta_groups og
JOIN okta_user_groups ug ON ug.okta_group_id = og.id
WHERE ug.okta_user_account_id = $1
  AND og.expired_at IS NULL
  AND og.last_observed_run_id IS NOT NULL
  AND ug.expired_at IS NULL
  AND ug.last_observed_run_id IS NOT NULL
ORDER BY og.name, og.external_id
`

func (q *Queries) ListOktaGroupsForIdpUser(ctx context.Context, oktaUserAccountID int64) ([]OktaGroup, error) {
	rows, err := q.db.Query(ctx, listOktaGroupsForIdpUser, oktaUserAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OktaGroup
	for rows.Next() {
		var i OktaGroup
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Type,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaUserAppAssignmentsForIdpUser = `-- name: ListOktaUserAppAssignmentsForIdpUser :many
SELECT
  ouaa.okta_user_account_id AS idp_user_id,
  ouaa.okta_app_id,
  ouaa.scope,
  ouaa.profile_json,
  ouaa.raw_json AS assignment_raw_json,
  oa.external_id AS okta_app_external_id,
  oa.label AS app_label,
  oa.name AS app_name,
  oa.status AS app_status,
  oa.sign_on_mode AS app_sign_on_mode,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_user_app_assignments ouaa
JOIN okta_apps oa ON oa.id = ouaa.okta_app_id
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE ouaa.okta_user_account_id = $1
  AND ouaa.expired_at IS NULL
  AND ouaa.last_observed_run_id IS NOT NULL
  AND oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
ORDER BY oa.label, oa.name, oa.external_id
`

type ListOktaUserAppAssignmentsForIdpUserRow struct {
	IdpUserID         int64  `json:"idp_user_id"`
	OktaAppID         int64  `json:"okta_app_id"`
	Scope             string `json:"scope"`
	ProfileJson       []byte `json:"profile_json"`
	AssignmentRawJson []byte `json:"assignment_raw_json"`
	OktaAppExternalID string `json:"okta_app_external_id"`
	AppLabel          string `json:"app_label"`
	AppName           string `json:"app_name"`
	AppStatus         string `json:"app_status"`
	AppSignOnMode     string `json:"app_sign_on_mode"`
	IntegrationKind   string `json:"integration_kind"`
}

func (q *Queries) ListOktaUserAppAssignmentsForIdpUser(ctx context.Context, oktaUserAccountID int64) ([]ListOktaUserAppAssignmentsForIdpUserRow, error) {
	rows, err := q.db.Query(ctx, listOktaUserAppAssignmentsForIdpUser, oktaUserAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaUserAppAssignmentsForIdpUserRow
	for rows.Next() {
		var i ListOktaUserAppAssignmentsForIdpUserRow
		if err := rows.Scan(
			&i.IdpUserID,
			&i.OktaAppID,
			&i.Scope,
			&i.ProfileJson,
			&i.AssignmentRawJson,
			&i.OktaAppExternalID,
			&i.AppLabel,
			&i.AppName,
			&i.AppStatus,
			&i.AppSignOnMode,
			&i.IntegrationKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertOktaAppGroupAssignmentsBulkByExternalIDs = `-- name: UpsertOktaAppGroupAssignmentsBulkByExternalIDs :execrows
WITH input AS (
  SELECT
    i,
    ($2::text[])[i] AS okta_app_external_id,
    ($3::text[])[i] AS okta_group_external_id,
    ($4::int[])[i] AS priority,
    ($5::jsonb[])[i] AS profile_json,
    ($6::jsonb[])[i] AS raw_json
  FROM generate_subscripts($2::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (okta_app_external_id, okta_group_external_id)
    okta_app_external_id,
    okta_group_external_id,
    priority,
    profile_json,
    raw_json
  FROM input
  ORDER BY okta_app_external_id, okta_group_external_id, i DESC
)
INSERT INTO okta_app_group_assignments (
  okta_app_id,
  okta_group_id,
  priority,
  profile_json,
  raw_json,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  oa.id,
  og.id,
  input.priority,
  input.profile_json,
  input.raw_json,
  $1::bigint,
  now(),
  now()
FROM dedup input
JOIN okta_apps oa ON oa.external_id = input.okta_app_external_id
JOIN okta_groups og ON og.external_id = input.okta_group_external_id
ON CONFLICT (okta_app_id, okta_group_id) DO UPDATE SET
  priority = EXCLUDED.priority,
  profile_json = EXCLUDED.profile_json,
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertOktaAppGroupAssignmentsBulkByExternalIDsParams struct {
	SeenInRunID          int64    `json:"seen_in_run_id"`
	OktaAppExternalIds   []string `json:"okta_app_external_ids"`
	OktaGroupExternalIds []string `json:"okta_group_external_ids"`
	Priorities           []int32  `json:"priorities"`
	ProfileJsons         [][]byte `json:"profile_jsons"`
	RawJsons             [][]byte `json:"raw_jsons"`
}

func (q *Queries) UpsertOktaAppGroupAssignmentsBulkByExternalIDs(ctx context.Context, arg UpsertOktaAppGroupAssignmentsBulkByExternalIDsParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertOktaAppGroupAssignmentsBulkByExternalIDs,
		arg.SeenInRunID,
		arg.OktaAppExternalIds,
		arg.OktaGroupExternalIds,
		arg.Priorities,
		arg.ProfileJsons,
		arg.RawJsons,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertOktaAppsBulk = `-- name: UpsertOktaAppsBulk :execrows
WITH input AS (
  SELECT
    i,
    ($2::text[])[i] AS external_id,
    ($3::text[])[i] AS label,
    ($4::text[])[i] AS name,
    ($5::text[])[i] AS status,
    ($6::text[])[i] AS sign_on_mode,
    ($7::jsonb[])[i] AS raw_json
  FROM generate_subscripts($2::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (external_id)
    external_id,
    label,
    name,
    status,
    sign_on_mode,
    raw_json
  FROM input
  ORDER BY external_id, i DESC
)
INSERT INTO okta_apps (
  external_id,
  label,
  name,
  status,
  sign_on_mode,
  raw_json,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  input.external_id,
  input.label,
  input.name,
  input.status,
  input.sign_on_mode,
  input.raw_json,
  $1::bigint,
  now(),
  now()
FROM dedup input
ON CONFLICT (external_id) DO UPDATE SET
  label = EXCLUDED.label,
  name = EXCLUDED.name,
  status = EXCLUDED.status,
  sign_on_mode = EXCLUDED.sign_on_mode,
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertOktaAppsBulkParams struct {
	SeenInRunID int64    `json:"seen_in_run_id"`
	ExternalIds []string `json:"external_ids"`
	Labels      []string `json:"labels"`
	Names       []string `json:"names"`
	Statuses    []string `json:"statuses"`
	SignOnModes []string `json:"sign_on_modes"`
	RawJsons    [][]byte `json:"raw_jsons"`
}

func (q *Queries) UpsertOktaAppsBulk(ctx context.Context, arg UpsertOktaAppsBulkParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertOktaAppsBulk,
		arg.SeenInRunID,
		arg.ExternalIds,
		arg.Labels,
		arg.Names,
		arg.Statuses,
		arg.SignOnModes,
		arg.RawJsons,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertOktaGroupsBulk = `-- name: UpsertOktaGroupsBulk :execrows
WITH input AS (
  SELECT
    i,
    ($2::text[])[i] AS external_id,
    ($3::text[])[i] AS name,
    ($4::text[])[i] AS type,
    ($5::jsonb[])[i] AS raw_json
  FROM generate_subscripts($2::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (external_id)
    external_id,
    name,
    type,
    raw_json
  FROM input
  ORDER BY external_id, i DESC
)
INSERT INTO okta_groups (
  external_id,
  name,
  type,
  raw_json,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  input.external_id,
  input.name,
  input.type,
  input.raw_json,
  $1::bigint,
  now(),
  now()
FROM dedup input
ON CONFLICT (external_id) DO UPDATE SET
  name = EXCLUDED.name,
  type = EXCLUDED.type,
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertOktaGroupsBulkParams struct {
	SeenInRunID int64    `json:"seen_in_run_id"`
	ExternalIds []string `json:"external_ids"`
	Names       []string `json:"names"`
	Types       []string `json:"types"`
	RawJsons    [][]byte `json:"raw_jsons"`
}

func (q *Queries) UpsertOktaGroupsBulk(ctx context.Context, arg UpsertOktaGroupsBulkParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertOktaGroupsBulk,
		arg.SeenInRunID,
		arg.ExternalIds,
		arg.Names,
		arg.Types,
		arg.RawJsons,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertOktaUserAppAssignmentsBulkByExternalIDs = `-- name: UpsertOktaUserAppAssignmentsBulkByExternalIDs :execrows
WITH run_source AS (
  SELECT sr.source_name
  FROM sync_runs sr
  WHERE sr.id = $1::bigint
  LIMIT 1
),
input AS (
  SELECT
    i,
    ($2::text[])[i] AS idp_user_external_id,
    ($3::text[])[i] AS okta_app_external_id,
    ($4::text[])[i] AS scope,
    ($5::jsonb[])[i] AS profile_json,
    ($6::jsonb[])[i] AS raw_json
  FROM generate_subscripts($2::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (idp_user_external_id, okta_app_external_id)
    idp_user_external_id,
    okta_app_external_id,
    scope,
    profile_json,
    raw_json
  FROM input
  ORDER BY idp_user_external_id, okta_app_external_id, i DESC
)
INSERT INTO okta_user_app_assignments (
  okta_user_account_id,
  okta_app_id,
  scope,
  profile_json,
  raw_json,
  seen_in_run_id,
  seen_at,
  updated_at
)
SELECT
  iu.id,
  oa.id,
  input.scope,
  input.profile_json,
  input.raw_json,
  $1::bigint,
  now(),
  now()
FROM dedup input
JOIN run_source rs ON TRUE
JOIN accounts iu
  ON iu.source_kind = 'okta'
  AND iu.source_name = rs.source_name
  AND iu.external_id = input.idp_user_external_id
JOIN okta_apps oa ON oa.external_id = input.okta_app_external_id
ON CONFLICT (okta_user_account_id, okta_app_id) DO UPDATE SET
  scope = EXCLUDED.scope,
  profile_json = EXCLUDED.profile_json,
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type UpsertOktaUserAppAssignmentsBulkByExternalIDsParams struct {
	SeenInRunID        int64    `json:"seen_in_run_id"`
	IdpUserExternalIds []string `json:"idp_user_external_ids"`
	OktaAppExternalIds []string `json:"okta_app_external_ids"`
	Scopes             []string `json:"scopes"`
	ProfileJsons       [][]byte `json:"profile_jsons"`
	RawJsons           [][]byte `json:"raw_jsons"`
}

func (q *Queries) UpsertOktaUserAppAssignmentsBulkByExternalIDs(ctx context.Context, arg UpsertOktaUserAppAssignmentsBulkByExternalIDsParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertOktaUserAppAssignmentsBulkByExternalIDs,
		arg.SeenInRunID,
		arg.IdpUserExternalIds,
		arg.OktaAppExternalIds,
		arg.Scopes,
		arg.ProfileJsons,
		arg.RawJsons,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const upsertOktaUserGroupsBulkByExternalIDs = `-- name: UpsertOktaUserGroupsBulkByExternalIDs :execrows
WITH run_source AS (
  SELECT sr.source_name
  FROM sync_runs sr
  WHERE sr.id = $1::bigint
  LIMIT 1
),
input AS (
  SELECT
    i,
    ($2::text[])[i] AS idp_user_external_id,
    ($3::text[])[i] AS okta_group_external_id
  FROM generate_subscripts($2::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (idp_user_external_id, okta_group_external_id)
    idp_user_external_id,
    okta_group_external_id
  FROM input
  ORDER BY idp_user_external_id, okta_group_external_id, i DESC
)
INSERT INTO okta_user_groups (okta_user_account_id, okta_group_id, seen_in_run_id, seen_at)
SELECT
  iu.id,
  og.id,
  $1::bigint,
  now()
FROM dedup d
JOIN run_source rs ON TRUE
JOIN accounts iu
  ON iu.source_kind = 'okta'
  AND iu.source_name = rs.source_name
  AND iu.external_id = d.idp_user_external_id
JOIN okta_groups og ON og.external_id = d.okta_group_external_id
ON CONFLICT (okta_user_account_id, okta_group_id) DO UPDATE SET
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at
`

type UpsertOktaUserGroupsBulkByExternalIDsParams struct {
	SeenInRunID          int64    `json:"seen_in_run_id"`
	IdpUserExternalIds   []string `json:"idp_user_external_ids"`
	OktaGroupExternalIds []string `json:"okta_group_external_ids"`
}

func (q *Queries) UpsertOktaUserGroupsBulkByExternalIDs(ctx context.Context, arg UpsertOktaUserGroupsBulkByExternalIDsParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertOktaUserGroupsBulkByExternalIDs, arg.SeenInRunID, arg.IdpUserExternalIds, arg.OktaGroupExternalIds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: okta_assignments.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countOktaAppUserAssignmentsByQuery = `-- name: CountOktaAppUserAssignmentsByQuery :one
SELECT count(*)
FROM okta_user_app_assignments ouaa
JOIN idp_users u ON u.id = ouaa.idp_user_id
WHERE
  ouaa.okta_app_id = $1
  AND ouaa.expired_at IS NULL
  AND ouaa.last_observed_run_id IS NOT NULL
  AND u.expired_at IS NULL
  AND u.last_observed_run_id IS NOT NULL
  AND (
    $2::text = ''
    OR ($2::text = 'active' AND u.status = 'ACTIVE')
    OR ($2::text = 'inactive' AND u.status <> 'ACTIVE')
  )
  AND (
    $3::text = ''
    OR u.email ILIKE ('%' || $3::text || '%')
    OR u.display_name ILIKE ('%' || $3::text || '%')
    OR u.external_id ILIKE ('%' || $3::text || '%')
  )
`

type CountOktaAppUserAssignmentsByQueryParams struct {
	OktaAppID int64  `json:"okta_app_id"`
	State     string `json:"state"`
	Query     string `json:"query"`
}

func (q *Queries) CountOktaAppUserAssignmentsByQuery(ctx context.Context, arg CountOktaAppUserAssignmentsByQueryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOktaAppUserAssignmentsByQuery, arg.OktaAppID, arg.State, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOktaApps = `-- name: CountOktaApps :one
SELECT count(*)
FROM okta_apps
WHERE expired_at IS NULL AND last_observed_run_id IS NOT NULL
`

func (q *Queries) CountOktaApps(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOktaApps)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOktaAppsByQuery = `-- name: CountOktaAppsByQuery :one
SELECT count(*)
FROM okta_apps oa
WHERE
  oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
  AND (
    $1::text = ''
    OR oa.label ILIKE ('%' || $1::text || '%')
    OR oa.name ILIKE ('%' || $1::text || '%')
    OR oa.external_id ILIKE ('%' || $1::text || '%')
  )
`

func (q *Queries) CountOktaAppsByQuery(ctx context.Context, query string) (int64, error) {
	row := q.db.QueryRow(ctx, countOktaAppsByQuery, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOktaAppGroupAssignmentsForApp = `-- name: DeleteOktaAppGroupAssignmentsForApp :exec
DELETE FROM okta_app_group_assignments WHERE okta_app_id = $1
`

func (q *Queries) DeleteOktaAppGroupAssignmentsForApp(ctx context.Context, oktaAppID int64) error {
	_, err := q.db.Exec(ctx, deleteOktaAppGroupAssignmentsForApp, oktaAppID)
	return err
}

const deleteOktaUserAppAssignmentsForIdpUser = `-- name: DeleteOktaUserAppAssignmentsForIdpUser :exec
DELETE FROM okta_user_app_assignments WHERE idp_user_id = $1
`

func (q *Queries) DeleteOktaUserAppAssignmentsForIdpUser(ctx context.Context, idpUserID int64) error {
	_, err := q.db.Exec(ctx, deleteOktaUserAppAssignmentsForIdpUser, idpUserID)
	return err
}

const deleteOktaUserGroupsForIdpUser = `-- name: DeleteOktaUserGroupsForIdpUser :exec
DELETE FROM okta_user_groups WHERE idp_user_id = $1
`

func (q *Queries) DeleteOktaUserGroupsForIdpUser(ctx context.Context, idpUserID int64) error {
	_, err := q.db.Exec(ctx, deleteOktaUserGroupsForIdpUser, idpUserID)
	return err
}

const getOktaAppByExternalIDWithIntegration = `-- name: GetOktaAppByExternalIDWithIntegration :one
SELECT
  oa.id,
  oa.external_id,
  oa.label,
  oa.name,
  oa.status,
  oa.sign_on_mode,
  oa.raw_json,
  oa.created_at,
  oa.updated_at,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_apps oa
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE oa.external_id = $1
  AND oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
`

type GetOktaAppByExternalIDWithIntegrationRow struct {
	ID              int64              `json:"id"`
	ExternalID      string             `json:"external_id"`
	Label           string             `json:"label"`
	Name            string             `json:"name"`
	Status          string             `json:"status"`
	SignOnMode      string             `json:"sign_on_mode"`
	RawJson         []byte             `json:"raw_json"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	IntegrationKind string             `json:"integration_kind"`
}

func (q *Queries) GetOktaAppByExternalIDWithIntegration(ctx context.Context, externalID string) (GetOktaAppByExternalIDWithIntegrationRow, error) {
	row := q.db.QueryRow(ctx, getOktaAppByExternalIDWithIntegration, externalID)
	var i GetOktaAppByExternalIDWithIntegrationRow
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Label,
		&i.Name,
		&i.Status,
		&i.SignOnMode,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IntegrationKind,
	)
	return i, err
}

const getOktaUserAppAssignmentForIdpUserByOktaAppExternalID = `-- name: GetOktaUserAppAssignmentForIdpUserByOktaAppExternalID :one
SELECT
  ouaa.idp_user_id,
  ouaa.okta_app_id,
  ouaa.scope,
  ouaa.profile_json,
  ouaa.raw_json AS assignment_raw_json,
  oa.external_id AS okta_app_external_id,
  oa.label AS app_label,
  oa.name AS app_name,
  oa.status AS app_status,
  oa.sign_on_mode AS app_sign_on_mode,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_user_app_assignments ouaa
JOIN okta_apps oa ON oa.id = ouaa.okta_app_id
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE
  ouaa.idp_user_id = $1
  AND ouaa.expired_at IS NULL
  AND ouaa.last_observed_run_id IS NOT NULL
  AND oa.external_id = $2
  AND oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
LIMIT 1
`

type GetOktaUserAppAssignmentForIdpUserByOktaAppExternalIDParams struct {
	IdpUserID         int64  `json:"idp_user_id"`
	OktaAppExternalID string `json:"okta_app_external_id"`
}

type GetOktaUserAppAssignmentForIdpUserByOktaAppExternalIDRow struct {
	IdpUserID         int64  `json:"idp_user_id"`
	OktaAppID         int64  `json:"okta_app_id"`
	Scope             string `json:"scope"`
	ProfileJson       []byte `json:"profile_json"`
	AssignmentRawJson []byte `json:"assignment_raw_json"`
	OktaAppExternalID string `json:"okta_app_external_id"`
	AppLabel          string `json:"app_label"`
	AppName           string `json:"app_name"`
	AppStatus         string `json:"app_status"`
	AppSignOnMode     string `json:"app_sign_on_mode"`
	IntegrationKind   string `json:"integration_kind"`
}

func (q *Queries) GetOktaUserAppAssignmentForIdpUserByOktaAppExternalID(ctx context.Context, arg GetOktaUserAppAssignmentForIdpUserByOktaAppExternalIDParams) (GetOktaUserAppAssignmentForIdpUserByOktaAppExternalIDRow, error) {
	row := q.db.QueryRow(ctx, getOktaUserAppAssignmentForIdpUserByOktaAppExternalID, arg.IdpUserID, arg.OktaAppExternalID)
	var i GetOktaUserAppAssignmentForIdpUserByOktaAppExternalIDRow
	err := row.Scan(
		&i.IdpUserID,
		&i.OktaAppID,
		&i.Scope,
		&i.ProfileJson,
		&i.AssignmentRawJson,
		&i.OktaAppExternalID,
		&i.AppLabel,
		&i.AppName,
		&i.AppStatus,
		&i.AppSignOnMode,
		&i.IntegrationKind,
	)
	return i, err
}

const insertOktaAppGroupAssignment = `-- name: InsertOktaAppGroupAssignment :exec
INSERT INTO okta_app_group_assignments (okta_app_id, okta_group_id, priority, profile_json, raw_json, seen_in_run_id, seen_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, now(), now())
ON CONFLICT (okta_app_id, okta_group_id) DO UPDATE SET
  priority = EXCLUDED.priority,
  profile_json = EXCLUDED.profile_json,
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type InsertOktaAppGroupAssignmentParams struct {
	OktaAppID   int64       `json:"okta_app_id"`
	OktaGroupID int64       `json:"okta_group_id"`
	Priority    int32       `json:"priority"`
	ProfileJson []byte      `json:"profile_json"`
	RawJson     []byte      `json:"raw_json"`
	SeenInRunID pgtype.Int8 `json:"seen_in_run_id"`
}

func (q *Queries) InsertOktaAppGroupAssignment(ctx context.Context, arg InsertOktaAppGroupAssignmentParams) error {
	_, err := q.db.Exec(ctx, insertOktaAppGroupAssignment,
		arg.OktaAppID,
		arg.OktaGroupID,
		arg.Priority,
		arg.ProfileJson,
		arg.RawJson,
		arg.SeenInRunID,
	)
	return err
}

const insertOktaUserAppAssignment = `-- name: InsertOktaUserAppAssignment :exec
INSERT INTO okta_user_app_assignments (idp_user_id, okta_app_id, scope, profile_json, raw_json, seen_in_run_id, seen_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, now(), now())
ON CONFLICT (idp_user_id, okta_app_id) DO UPDATE SET
  scope = EXCLUDED.scope,
  profile_json = EXCLUDED.profile_json,
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
`

type InsertOktaUserAppAssignmentParams struct {
	IdpUserID   int64       `json:"idp_user_id"`
	OktaAppID   int64       `json:"okta_app_id"`
	Scope       string      `json:"scope"`
	ProfileJson []byte      `json:"profile_json"`
	RawJson     []byte      `json:"raw_json"`
	SeenInRunID pgtype.Int8 `json:"seen_in_run_id"`
}

func (q *Queries) InsertOktaUserAppAssignment(ctx context.Context, arg InsertOktaUserAppAssignmentParams) error {
	_, err := q.db.Exec(ctx, insertOktaUserAppAssignment,
		arg.IdpUserID,
		arg.OktaAppID,
		arg.Scope,
		arg.ProfileJson,
		arg.RawJson,
		arg.SeenInRunID,
	)
	return err
}

const insertOktaUserGroup = `-- name: InsertOktaUserGroup :exec
INSERT INTO okta_user_groups (idp_user_id, okta_group_id, seen_in_run_id, seen_at)
VALUES ($1, $2, $3, now())
ON CONFLICT (idp_user_id, okta_group_id) DO UPDATE SET
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at
`

type InsertOktaUserGroupParams struct {
	IdpUserID   int64       `json:"idp_user_id"`
	OktaGroupID int64       `json:"okta_group_id"`
	SeenInRunID pgtype.Int8 `json:"seen_in_run_id"`
}

func (q *Queries) InsertOktaUserGroup(ctx context.Context, arg InsertOktaUserGroupParams) error {
	_, err := q.db.Exec(ctx, insertOktaUserGroup, arg.IdpUserID, arg.OktaGroupID, arg.SeenInRunID)
	return err
}

const listOktaAppGrantingGroupsForIdpUserByOktaAppExternalID = `-- name: ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalID :many
SELECT
  og.name AS okta_group_name,
  og.external_id AS okta_group_external_id
FROM okta_user_groups ug
JOIN okta_app_group_assignments oga ON oga.okta_group_id = ug.okta_group_id
JOIN okta_groups og ON og.id = ug.okta_group_id
JOIN okta_apps oa ON oa.id = oga.okta_app_id
WHERE
  ug.idp_user_id = $1
  AND ug.expired_at IS NULL
  AND ug.last_observed_run_id IS NOT NULL
  AND oga.expired_at IS NULL
  AND oga.last_observed_run_id IS NOT NULL
  AND og.expired_at IS NULL
  AND og.last_observed_run_id IS NOT NULL
  AND oa.external_id = $2
  AND oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
ORDER BY og.name, og.external_id
`

type ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDParams struct {
	IdpUserID         int64  `json:"idp_user_id"`
	OktaAppExternalID string `json:"okta_app_external_id"`
}

type ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDRow struct {
	OktaGroupName       string `json:"okta_group_name"`
	OktaGroupExternalID string `json:"okta_group_external_id"`
}

func (q *Queries) ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalID(ctx context.Context, arg ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDParams) ([]ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppGrantingGroupsForIdpUserByOktaAppExternalID, arg.IdpUserID, arg.OktaAppExternalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDRow
	for rows.Next() {
		var i ListOktaAppGrantingGroupsForIdpUserByOktaAppExternalIDRow
		if err := rows.Scan(&i.OktaGroupName, &i.OktaGroupExternalID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppGrantingGroupsForIdpUsers = `-- name: ListOktaAppGrantingGroupsForIdpUsers :many
SELECT
  ug.idp_user_id,
  og.name AS okta_group_name,
  og.external_id AS okta_group_external_id
FROM okta_user_groups ug
JOIN okta_app_group_assignments oga ON oga.okta_group_id = ug.okta_group_id
JOIN okta_groups og ON og.id = ug.okta_group_id
WHERE
  oga.okta_app_id = $1
  AND ug.expired_at IS NULL
  AND ug.last_observed_run_id IS NOT NULL
  AND oga.expired_at IS NULL
  AND oga.last_observed_run_id IS NOT NULL
  AND og.expired_at IS NULL
  AND og.last_observed_run_id IS NOT NULL
  AND ug.idp_user_id = ANY($2::bigint[])
ORDER BY ug.idp_user_id, og.name, og.external_id
`

type ListOktaAppGrantingGroupsForIdpUsersParams struct {
	OktaAppID  int64   `json:"okta_app_id"`
	IdpUserIds []int64 `json:"idp_user_ids"`
}

type ListOktaAppGrantingGroupsForIdpUsersRow struct {
	IdpUserID           int64  `json:"idp_user_id"`
	OktaGroupName       string `json:"okta_group_name"`
	OktaGroupExternalID string `json:"okta_group_external_id"`
}

func (q *Queries) ListOktaAppGrantingGroupsForIdpUsers(ctx context.Context, arg ListOktaAppGrantingGroupsForIdpUsersParams) ([]ListOktaAppGrantingGroupsForIdpUsersRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppGrantingGroupsForIdpUsers, arg.OktaAppID, arg.IdpUserIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppGrantingGroupsForIdpUsersRow
	for rows.Next() {
		var i ListOktaAppGrantingGroupsForIdpUsersRow
		if err := rows.Scan(&i.IdpUserID, &i.OktaGroupName, &i.OktaGroupExternalID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppGroupAssignmentsByAppIDs = `-- name: ListOktaAppGroupAssignmentsByAppIDs :many
SELECT
  oga.okta_app_id,
  oga.okta_group_id,
  og.name AS okta_group_name,
  og.external_id AS okta_group_external_id
FROM okta_app_group_assignments oga
LEFT JOIN okta_groups og
  ON og.id = oga.okta_group_id
  AND og.expired_at IS NULL
  AND og.last_observed_run_id IS NOT NULL
WHERE oga.okta_app_id = ANY($1::bigint[])
  AND oga.expired_at IS NULL
  AND oga.last_observed_run_id IS NOT NULL
ORDER BY oga.okta_app_id, og.name, og.external_id
`

type ListOktaAppGroupAssignmentsByAppIDsRow struct {
	OktaAppID           int64       `json:"okta_app_id"`
	OktaGroupID         int64       `json:"okta_group_id"`
	OktaGroupName       pgtype.Text `json:"okta_group_name"`
	OktaGroupExternalID pgtype.Text `json:"okta_group_external_id"`
}

func (q *Queries) ListOktaAppGroupAssignmentsByAppIDs(ctx context.Context, dollar_1 []int64) ([]ListOktaAppGroupAssignmentsByAppIDsRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppGroupAssignmentsByAppIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppGroupAssignmentsByAppIDsRow
	for rows.Next() {
		var i ListOktaAppGroupAssignmentsByAppIDsRow
		if err := rows.Scan(
			&i.OktaAppID,
			&i.OktaGroupID,
			&i.OktaGroupName,
			&i.OktaGroupExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppUserAssignmentsPageByQuery = `-- name: ListOktaAppUserAssignmentsPageByQuery :many
SELECT
  u.id AS idp_user_id,
  u.external_id AS idp_user_external_id,
  u.email AS idp_user_email,
  u.display_name AS idp_user_display_name,
  u.status AS idp_user_status,
  ouaa.scope,
  ouaa.profile_json
FROM okta_user_app_assignments ouaa
JOIN idp_users u ON u.id = ouaa.idp_user_id
WHERE
  ouaa.okta_app_id = $1
  AND ouaa.expired_at IS NULL
  AND ouaa.last_observed_run_id IS NOT NULL
  AND u.expired_at IS NULL
  AND u.last_observed_run_id IS NOT NULL
  AND (
    $2::text = ''
    OR ($2::text = 'active' AND u.status = 'ACTIVE')
    OR ($2::text = 'inactive' AND u.status <> 'ACTIVE')
  )
  AND (
    $3::text = ''
    OR u.email ILIKE ('%' || $3::text || '%')
    OR u.display_name ILIKE ('%' || $3::text || '%')
    OR u.external_id ILIKE ('%' || $3::text || '%')
  )
ORDER BY (u.display_name = ''), u.display_name, u.email, u.external_id
LIMIT $5::int
OFFSET $4::int
`

type ListOktaAppUserAssignmentsPageByQueryParams struct {
	OktaAppID  int64  `json:"okta_app_id"`
	State      string `json:"state"`
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

type ListOktaAppUserAssignmentsPageByQueryRow struct {
	IdpUserID          int64  `json:"idp_user_id"`
	IdpUserExternalID  string `json:"idp_user_external_id"`
	IdpUserEmail       string `json:"idp_user_email"`
	IdpUserDisplayName string `json:"idp_user_display_name"`
	IdpUserStatus      string `json:"idp_user_status"`
	Scope              string `json:"scope"`
	ProfileJson        []byte `json:"profile_json"`
}

func (q *Queries) ListOktaAppUserAssignmentsPageByQuery(ctx context.Context, arg ListOktaAppUserAssignmentsPageByQueryParams) ([]ListOktaAppUserAssignmentsPageByQueryRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppUserAssignmentsPageByQuery,
		arg.OktaAppID,
		arg.State,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppUserAssignmentsPageByQueryRow
	for rows.Next() {
		var i ListOktaAppUserAssignmentsPageByQueryRow
		if err := rows.Scan(
			&i.IdpUserID,
			&i.IdpUserExternalID,
			&i.IdpUserEmail,
			&i.IdpUserDisplayName,
			&i.IdpUserStatus,
			&i.Scope,
			&i.ProfileJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaApps = `-- name: ListOktaApps :many
SELECT id, external_id, label, name, status, sign_on_mode, raw_json, created_at, updated_at, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
FROM okta_apps
WHERE expired_at IS NULL AND last_observed_run_id IS NOT NULL
ORDER BY label, name, external_id
`

func (q *Queries) ListOktaApps(ctx context.Context) ([]OktaApp, error) {
	rows, err := q.db.Query(ctx, listOktaApps)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OktaApp
	for rows.Next() {
		var i OktaApp
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Label,
			&i.Name,
			&i.Status,
			&i.SignOnMode,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppsForCommand = `-- name: ListOktaAppsForCommand :many
SELECT
  oa.external_id,
  oa.label,
  oa.name,
  oa.status,
  oa.sign_on_mode,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_apps oa
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE oa.expired_at IS NULL AND oa.last_observed_run_id IS NOT NULL
ORDER BY (m.integration_kind IS NULL), oa.label, oa.name, oa.external_id
`

type ListOktaAppsForCommandRow struct {
	ExternalID      string `json:"external_id"`
	Label           string `json:"label"`
	Name            string `json:"name"`
	Status          string `json:"status"`
	SignOnMode      string `json:"sign_on_mode"`
	IntegrationKind string `json:"integration_kind"`
}

func (q *Queries) ListOktaAppsForCommand(ctx context.Context) ([]ListOktaAppsForCommandRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppsForCommand)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppsForCommandRow
	for rows.Next() {
		var i ListOktaAppsForCommandRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.Label,
			&i.Name,
			&i.Status,
			&i.SignOnMode,
			&i.IntegrationKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppsPage = `-- name: ListOktaAppsPage :many
SELECT
  oa.external_id,
  oa.label,
  oa.name,
  oa.status,
  oa.sign_on_mode,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_apps oa
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE oa.expired_at IS NULL AND oa.last_observed_run_id IS NOT NULL
ORDER BY (m.integration_kind IS NULL), oa.label, oa.name, oa.external_id
LIMIT $2::int
OFFSET $1::int
`

type ListOktaAppsPageParams struct {
	PageOffset int32 `json:"page_offset"`
	PageLimit  int32 `json:"page_limit"`
}

type ListOktaAppsPageRow struct {
	ExternalID      string `json:"external_id"`
	Label           string `json:"label"`
	Name            string `json:"name"`
	Status          string `json:"status"`
	SignOnMode      string `json:"sign_on_mode"`
	IntegrationKind string `json:"integration_kind"`
}

func (q *Queries) ListOktaAppsPage(ctx context.Context, arg ListOktaAppsPageParams) ([]ListOktaAppsPageRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppsPage, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppsPageRow
	for rows.Next() {
		var i ListOktaAppsPageRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.Label,
			&i.Name,
			&i.Status,
			&i.SignOnMode,
			&i.IntegrationKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaAppsPageByQuery = `-- name: ListOktaAppsPageByQuery :many
SELECT
  oa.external_id,
  oa.label,
  oa.name,
  oa.status,
  oa.sign_on_mode,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_apps oa
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE
  oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
  AND (
    $1::text = ''
    OR oa.label ILIKE ('%' || $1::text || '%')
    OR oa.name ILIKE ('%' || $1::text || '%')
    OR oa.external_id ILIKE ('%' || $1::text || '%')
  )
ORDER BY (m.integration_kind IS NULL), oa.label, oa.name, oa.external_id
LIMIT $3::int
OFFSET $2::int
`

type ListOktaAppsPageByQueryParams struct {
	Query      string `json:"query"`
	PageOffset int32  `json:"page_offset"`
	PageLimit  int32  `json:"page_limit"`
}

type ListOktaAppsPageByQueryRow struct {
	ExternalID      string `json:"external_id"`
	Label           string `json:"label"`
	Name            string `json:"name"`
	Status          string `json:"status"`
	SignOnMode      string `json:"sign_on_mode"`
	IntegrationKind string `json:"integration_kind"`
}

func (q *Queries) ListOktaAppsPageByQuery(ctx context.Context, arg ListOktaAppsPageByQueryParams) ([]ListOktaAppsPageByQueryRow, error) {
	rows, err := q.db.Query(ctx, listOktaAppsPageByQuery, arg.Query, arg.PageOffset, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaAppsPageByQueryRow
	for rows.Next() {
		var i ListOktaAppsPageByQueryRow
		if err := rows.Scan(
			&i.ExternalID,
			&i.Label,
			&i.Name,
			&i.Status,
			&i.SignOnMode,
			&i.IntegrationKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaGroupsForIdpUser = `-- name: ListOktaGroupsForIdpUser :many
SELECT og.id, og.external_id, og.name, og.type, og.raw_json, og.created_at, og.updated_at, og.seen_in_run_id, og.seen_at, og.last_observed_run_id, og.last_observed_at, og.expired_at, og.expired_run_id
FROM okta_groups og
JOIN okta_user_groups ug ON ug.okta_group_id = og.id
WHERE ug.idp_user_id = $1
  AND og.expired_at IS NULL
  AND og.last_observed_run_id IS NOT NULL
  AND ug.expired_at IS NULL
  AND ug.last_observed_run_id IS NOT NULL
ORDER BY og.name, og.external_id
`

func (q *Queries) ListOktaGroupsForIdpUser(ctx context.Context, idpUserID int64) ([]OktaGroup, error) {
	rows, err := q.db.Query(ctx, listOktaGroupsForIdpUser, idpUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OktaGroup
	for rows.Next() {
		var i OktaGroup
		if err := rows.Scan(
			&i.ID,
			&i.ExternalID,
			&i.Name,
			&i.Type,
			&i.RawJson,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeenInRunID,
			&i.SeenAt,
			&i.LastObservedRunID,
			&i.LastObservedAt,
			&i.ExpiredAt,
			&i.ExpiredRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOktaUserAppAssignmentsForIdpUser = `-- name: ListOktaUserAppAssignmentsForIdpUser :many
SELECT
  ouaa.idp_user_id,
  ouaa.okta_app_id,
  ouaa.scope,
  ouaa.profile_json,
  ouaa.raw_json AS assignment_raw_json,
  oa.external_id AS okta_app_external_id,
  oa.label AS app_label,
  oa.name AS app_name,
  oa.status AS app_status,
  oa.sign_on_mode AS app_sign_on_mode,
  COALESCE(m.integration_kind, '') AS integration_kind
FROM okta_user_app_assignments ouaa
JOIN okta_apps oa ON oa.id = ouaa.okta_app_id
LEFT JOIN integration_okta_app_map m ON m.okta_app_external_id = oa.external_id
WHERE ouaa.idp_user_id = $1
  AND ouaa.expired_at IS NULL
  AND ouaa.last_observed_run_id IS NOT NULL
  AND oa.expired_at IS NULL
  AND oa.last_observed_run_id IS NOT NULL
ORDER BY oa.label, oa.name, oa.external_id
`

type ListOktaUserAppAssignmentsForIdpUserRow struct {
	IdpUserID         int64  `json:"idp_user_id"`
	OktaAppID         int64  `json:"okta_app_id"`
	Scope             string `json:"scope"`
	ProfileJson       []byte `json:"profile_json"`
	AssignmentRawJson []byte `json:"assignment_raw_json"`
	OktaAppExternalID string `json:"okta_app_external_id"`
	AppLabel          string `json:"app_label"`
	AppName           string `json:"app_name"`
	AppStatus         string `json:"app_status"`
	AppSignOnMode     string `json:"app_sign_on_mode"`
	IntegrationKind   string `json:"integration_kind"`
}

func (q *Queries) ListOktaUserAppAssignmentsForIdpUser(ctx context.Context, idpUserID int64) ([]ListOktaUserAppAssignmentsForIdpUserRow, error) {
	rows, err := q.db.Query(ctx, listOktaUserAppAssignmentsForIdpUser, idpUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOktaUserAppAssignmentsForIdpUserRow
	for rows.Next() {
		var i ListOktaUserAppAssignmentsForIdpUserRow
		if err := rows.Scan(
			&i.IdpUserID,
			&i.OktaAppID,
			&i.Scope,
			&i.ProfileJson,
			&i.AssignmentRawJson,
			&i.OktaAppExternalID,
			&i.AppLabel,
			&i.AppName,
			&i.AppStatus,
			&i.AppSignOnMode,
			&i.IntegrationKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertOktaApp = `-- name: UpsertOktaApp :one
INSERT INTO okta_apps (external_id, label, name, status, sign_on_mode, raw_json, seen_in_run_id, seen_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, now(), now())
ON CONFLICT (external_id) DO UPDATE SET
  label = EXCLUDED.label,
  name = EXCLUDED.name,
  status = EXCLUDED.status,
  sign_on_mode = EXCLUDED.sign_on_mode,
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
RETURNING id, external_id, label, name, status, sign_on_mode, raw_json, created_at, updated_at, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
`

type UpsertOktaAppParams struct {
	ExternalID  string      `json:"external_id"`
	Label       string      `json:"label"`
	Name        string      `json:"name"`
	Status      string      `json:"status"`
	SignOnMode  string      `json:"sign_on_mode"`
	RawJson     []byte      `json:"raw_json"`
	SeenInRunID pgtype.Int8 `json:"seen_in_run_id"`
}

func (q *Queries) UpsertOktaApp(ctx context.Context, arg UpsertOktaAppParams) (OktaApp, error) {
	row := q.db.QueryRow(ctx, upsertOktaApp,
		arg.ExternalID,
		arg.Label,
		arg.Name,
		arg.Status,
		arg.SignOnMode,
		arg.RawJson,
		arg.SeenInRunID,
	)
	var i OktaApp
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Label,
		&i.Name,
		&i.Status,
		&i.SignOnMode,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
	)
	return i, err
}

const upsertOktaGroup = `-- name: UpsertOktaGroup :one
INSERT INTO okta_groups (external_id, name, type, raw_json, seen_in_run_id, seen_at, updated_at)
VALUES ($1, $2, $3, $4, $5, now(), now())
ON CONFLICT (external_id) DO UPDATE SET
  name = EXCLUDED.name,
  type = EXCLUDED.type,
  raw_json = EXCLUDED.raw_json,
  seen_in_run_id = EXCLUDED.seen_in_run_id,
  seen_at = EXCLUDED.seen_at,
  updated_at = now()
RETURNING id, external_id, name, type, raw_json, created_at, updated_at, seen_in_run_id, seen_at, last_observed_run_id, last_observed_at, expired_at, expired_run_id
`

type UpsertOktaGroupParams struct {
	ExternalID  string      `json:"external_id"`
	Name        string      `json:"name"`
	Type        string      `json:"type"`
	RawJson     []byte      `json:"raw_json"`
	SeenInRunID pgtype.Int8 `json:"seen_in_run_id"`
}

func (q *Queries) UpsertOktaGroup(ctx context.Context, arg UpsertOktaGroupParams) (OktaGroup, error) {
	row := q.db.QueryRow(ctx, upsertOktaGroup,
		arg.ExternalID,
		arg.Name,
		arg.Type,
		arg.RawJson,
		arg.SeenInRunID,
	)
	var i OktaGroup
	err := row.Scan(
		&i.ID,
		&i.ExternalID,
		&i.Name,
		&i.Type,
		&i.RawJson,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SeenInRunID,
		&i.SeenAt,
		&i.LastObservedRunID,
		&i.LastObservedAt,
		&i.ExpiredAt,
		&i.ExpiredRunID,
	)
	return i, err
}

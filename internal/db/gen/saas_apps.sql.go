// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: saas_apps.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSaaSAppsByFilters = `-- name: CountSaaSAppsByFilters :one
WITH configured_sources AS (
  SELECT
    k.kind AS source_kind,
    n.name AS source_name
  FROM unnest($6::text[]) WITH ORDINALITY AS k(kind, ord)
  JOIN unnest($7::text[]) WITH ORDINALITY AS n(name, ord) USING (ord)
)
SELECT count(*)
FROM saas_apps sa
WHERE EXISTS (
  SELECT 1
  FROM saas_app_sources sas
  JOIN configured_sources cs
    ON cs.source_kind = sas.source_kind
   AND cs.source_name = sas.source_name
  WHERE sas.saas_app_id = sa.id
    AND sas.expired_at IS NULL
    AND sas.last_observed_run_id IS NOT NULL
    AND (
      $1::text = ''
      OR sas.source_kind = $1::text
    )
    AND (
      $2::text = ''
      OR sas.source_name = $2::text
    )
)
  AND (
    $3::text = ''
    OR sa.managed_state = $3::text
  )
  AND (
    $4::text = ''
    OR sa.risk_level = $4::text
  )
  AND (
    $5::text = ''
    OR sa.display_name ILIKE ('%' || $5::text || '%')
    OR sa.primary_domain ILIKE ('%' || $5::text || '%')
    OR sa.vendor_name ILIKE ('%' || $5::text || '%')
    OR sa.canonical_key ILIKE ('%' || $5::text || '%')
  )
`

type CountSaaSAppsByFiltersParams struct {
	SourceKind            string   `json:"source_kind"`
	SourceName            string   `json:"source_name"`
	ManagedState          string   `json:"managed_state"`
	RiskLevel             string   `json:"risk_level"`
	Query                 string   `json:"query"`
	ConfiguredSourceKinds []string `json:"configured_source_kinds"`
	ConfiguredSourceNames []string `json:"configured_source_names"`
}

func (q *Queries) CountSaaSAppsByFilters(ctx context.Context, arg CountSaaSAppsByFiltersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSaaSAppsByFilters,
		arg.SourceKind,
		arg.SourceName,
		arg.ManagedState,
		arg.RiskLevel,
		arg.Query,
		arg.ConfiguredSourceKinds,
		arg.ConfiguredSourceNames,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSaaSAppsGroupedByManagedState = `-- name: CountSaaSAppsGroupedByManagedState :many
WITH configured_sources AS (
  SELECT
    k.kind AS source_kind,
    n.name AS source_name
  FROM unnest($1::text[]) WITH ORDINALITY AS k(kind, ord)
  JOIN unnest($2::text[]) WITH ORDINALITY AS n(name, ord) USING (ord)
)
SELECT sa.managed_state, count(*) AS app_count
FROM saas_apps sa
WHERE EXISTS (
  SELECT 1
  FROM saas_app_sources sas
  JOIN configured_sources cs
    ON cs.source_kind = sas.source_kind
   AND cs.source_name = sas.source_name
  WHERE sas.saas_app_id = sa.id
    AND sas.expired_at IS NULL
    AND sas.last_observed_run_id IS NOT NULL
)
GROUP BY sa.managed_state
ORDER BY sa.managed_state
`

type CountSaaSAppsGroupedByManagedStateParams struct {
	ConfiguredSourceKinds []string `json:"configured_source_kinds"`
	ConfiguredSourceNames []string `json:"configured_source_names"`
}

type CountSaaSAppsGroupedByManagedStateRow struct {
	ManagedState string `json:"managed_state"`
	AppCount     int64  `json:"app_count"`
}

func (q *Queries) CountSaaSAppsGroupedByManagedState(ctx context.Context, arg CountSaaSAppsGroupedByManagedStateParams) ([]CountSaaSAppsGroupedByManagedStateRow, error) {
	rows, err := q.db.Query(ctx, countSaaSAppsGroupedByManagedState, arg.ConfiguredSourceKinds, arg.ConfiguredSourceNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountSaaSAppsGroupedByManagedStateRow
	for rows.Next() {
		var i CountSaaSAppsGroupedByManagedStateRow
		if err := rows.Scan(&i.ManagedState, &i.AppCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countSaaSAppsGroupedByRiskLevel = `-- name: CountSaaSAppsGroupedByRiskLevel :many
WITH configured_sources AS (
  SELECT
    k.kind AS source_kind,
    n.name AS source_name
  FROM unnest($1::text[]) WITH ORDINALITY AS k(kind, ord)
  JOIN unnest($2::text[]) WITH ORDINALITY AS n(name, ord) USING (ord)
)
SELECT sa.risk_level, count(*) AS app_count
FROM saas_apps sa
WHERE EXISTS (
  SELECT 1
  FROM saas_app_sources sas
  JOIN configured_sources cs
    ON cs.source_kind = sas.source_kind
   AND cs.source_name = sas.source_name
  WHERE sas.saas_app_id = sa.id
    AND sas.expired_at IS NULL
    AND sas.last_observed_run_id IS NOT NULL
)
GROUP BY sa.risk_level
ORDER BY sa.risk_level
`

type CountSaaSAppsGroupedByRiskLevelParams struct {
	ConfiguredSourceKinds []string `json:"configured_source_kinds"`
	ConfiguredSourceNames []string `json:"configured_source_names"`
}

type CountSaaSAppsGroupedByRiskLevelRow struct {
	RiskLevel string `json:"risk_level"`
	AppCount  int64  `json:"app_count"`
}

func (q *Queries) CountSaaSAppsGroupedByRiskLevel(ctx context.Context, arg CountSaaSAppsGroupedByRiskLevelParams) ([]CountSaaSAppsGroupedByRiskLevelRow, error) {
	rows, err := q.db.Query(ctx, countSaaSAppsGroupedByRiskLevel, arg.ConfiguredSourceKinds, arg.ConfiguredSourceNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountSaaSAppsGroupedByRiskLevelRow
	for rows.Next() {
		var i CountSaaSAppsGroupedByRiskLevelRow
		if err := rows.Scan(&i.RiskLevel, &i.AppCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSaaSAppByID = `-- name: GetSaaSAppByID :one
SELECT id, canonical_key, display_name, primary_domain, vendor_name, managed_state, managed_reason, bound_connector_kind, bound_connector_source_name, risk_score, risk_level, suggested_business_criticality, suggested_data_classification, first_seen_at, last_seen_at, created_at, updated_at
FROM saas_apps
WHERE id = $1
`

func (q *Queries) GetSaaSAppByID(ctx context.Context, id int64) (SaasApp, error) {
	row := q.db.QueryRow(ctx, getSaaSAppByID, id)
	var i SaasApp
	err := row.Scan(
		&i.ID,
		&i.CanonicalKey,
		&i.DisplayName,
		&i.PrimaryDomain,
		&i.VendorName,
		&i.ManagedState,
		&i.ManagedReason,
		&i.BoundConnectorKind,
		&i.BoundConnectorSourceName,
		&i.RiskScore,
		&i.RiskLevel,
		&i.SuggestedBusinessCriticality,
		&i.SuggestedDataClassification,
		&i.FirstSeenAt,
		&i.LastSeenAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSaaSAppHotspots = `-- name: ListSaaSAppHotspots :many
WITH configured_sources AS (
  SELECT
    k.kind AS source_kind,
    n.name AS source_name
  FROM unnest($4::text[]) WITH ORDINALITY AS k(kind, ord)
  JOIN unnest($5::text[]) WITH ORDINALITY AS n(name, ord) USING (ord)
)
SELECT
  sa.id, sa.canonical_key, sa.display_name, sa.primary_domain, sa.vendor_name, sa.managed_state, sa.managed_reason, sa.bound_connector_kind, sa.bound_connector_source_name, sa.risk_score, sa.risk_level, sa.suggested_business_criticality, sa.suggested_data_classification, sa.first_seen_at, sa.last_seen_at, sa.created_at, sa.updated_at,
  go.owner_identity_id,
  COALESCE(owner.display_name, '') AS owner_display_name,
  COALESCE(owner.primary_email, '') AS owner_primary_email,
  COALESCE(actor_stats.actors_30d, 0)::bigint AS actors_30d
FROM saas_apps sa
LEFT JOIN saas_app_governance_overrides go ON go.saas_app_id = sa.id
LEFT JOIN identities owner ON owner.id = go.owner_identity_id
LEFT JOIN LATERAL (
  SELECT
    count(DISTINCT COALESCE(NULLIF(trim(e.actor_external_id), ''), NULLIF(lower(trim(e.actor_email)), ''))) AS actors_30d
  FROM saas_app_events e
  WHERE e.saas_app_id = sa.id
    AND e.expired_at IS NULL
    AND e.last_observed_run_id IS NOT NULL
    AND e.observed_at >= now() - interval '30 days'
) actor_stats ON TRUE
WHERE sa.risk_score >= 60
  AND EXISTS (
    SELECT 1
    FROM saas_app_sources sas
    JOIN configured_sources cs
      ON cs.source_kind = sas.source_kind
     AND cs.source_name = sas.source_name
    WHERE sas.saas_app_id = sa.id
      AND sas.expired_at IS NULL
      AND sas.last_observed_run_id IS NOT NULL
      AND (
        $1::text = ''
        OR sas.source_kind = $1::text
      )
      AND (
        $2::text = ''
        OR sas.source_name = $2::text
      )
  )
ORDER BY sa.risk_score DESC, sa.last_seen_at DESC, sa.id ASC
LIMIT $3::int
`

type ListSaaSAppHotspotsParams struct {
	SourceKind            string   `json:"source_kind"`
	SourceName            string   `json:"source_name"`
	LimitRows             int32    `json:"limit_rows"`
	ConfiguredSourceKinds []string `json:"configured_source_kinds"`
	ConfiguredSourceNames []string `json:"configured_source_names"`
}

type ListSaaSAppHotspotsRow struct {
	ID                           int64              `json:"id"`
	CanonicalKey                 string             `json:"canonical_key"`
	DisplayName                  string             `json:"display_name"`
	PrimaryDomain                string             `json:"primary_domain"`
	VendorName                   string             `json:"vendor_name"`
	ManagedState                 string             `json:"managed_state"`
	ManagedReason                string             `json:"managed_reason"`
	BoundConnectorKind           string             `json:"bound_connector_kind"`
	BoundConnectorSourceName     string             `json:"bound_connector_source_name"`
	RiskScore                    int32              `json:"risk_score"`
	RiskLevel                    string             `json:"risk_level"`
	SuggestedBusinessCriticality string             `json:"suggested_business_criticality"`
	SuggestedDataClassification  string             `json:"suggested_data_classification"`
	FirstSeenAt                  pgtype.Timestamptz `json:"first_seen_at"`
	LastSeenAt                   pgtype.Timestamptz `json:"last_seen_at"`
	CreatedAt                    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                    pgtype.Timestamptz `json:"updated_at"`
	OwnerIdentityID              pgtype.Int8        `json:"owner_identity_id"`
	OwnerDisplayName             string             `json:"owner_display_name"`
	OwnerPrimaryEmail            string             `json:"owner_primary_email"`
	Actors30d                    int64              `json:"actors_30d"`
}

func (q *Queries) ListSaaSAppHotspots(ctx context.Context, arg ListSaaSAppHotspotsParams) ([]ListSaaSAppHotspotsRow, error) {
	rows, err := q.db.Query(ctx, listSaaSAppHotspots,
		arg.SourceKind,
		arg.SourceName,
		arg.LimitRows,
		arg.ConfiguredSourceKinds,
		arg.ConfiguredSourceNames,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSaaSAppHotspotsRow
	for rows.Next() {
		var i ListSaaSAppHotspotsRow
		if err := rows.Scan(
			&i.ID,
			&i.CanonicalKey,
			&i.DisplayName,
			&i.PrimaryDomain,
			&i.VendorName,
			&i.ManagedState,
			&i.ManagedReason,
			&i.BoundConnectorKind,
			&i.BoundConnectorSourceName,
			&i.RiskScore,
			&i.RiskLevel,
			&i.SuggestedBusinessCriticality,
			&i.SuggestedDataClassification,
			&i.FirstSeenAt,
			&i.LastSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerIdentityID,
			&i.OwnerDisplayName,
			&i.OwnerPrimaryEmail,
			&i.Actors30d,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSaaSAppPostureInputs = `-- name: ListSaaSAppPostureInputs :many
WITH active_events AS (
  SELECT e.id, e.saas_app_id, e.source_kind, e.source_name, e.signal_kind, e.event_external_id, e.source_app_id, e.source_app_name, e.source_app_domain, e.actor_external_id, e.actor_email, e.actor_display_name, e.observed_at, e.scopes_json, e.raw_json, e.seen_in_run_id, e.seen_at, e.last_observed_run_id, e.last_observed_at, e.expired_at, e.expired_run_id, e.created_at, e.updated_at
  FROM saas_app_events e
  WHERE e.expired_at IS NULL
    AND e.last_observed_run_id IS NOT NULL
),
actor_counts AS (
  SELECT
    e.saas_app_id,
    count(DISTINCT COALESCE(NULLIF(trim(e.actor_external_id), ''), NULLIF(lower(trim(e.actor_email)), ''))) FILTER (WHERE e.observed_at >= now() - interval '30 days') AS actors_30d
  FROM active_events e
  GROUP BY e.saas_app_id
),
scope_flags AS (
  SELECT
    e.saas_app_id,
    bool_or(
      lower(e.scopes_json::text) LIKE '%directory.readwrite.all%'
      OR lower(e.scopes_json::text) LIKE '%application.readwrite.all%'
      OR lower(e.scopes_json::text) LIKE '%rolemanagement.readwrite.directory%'
      OR lower(e.scopes_json::text) LIKE '%mailboxsettings.readwrite%'
      OR lower(e.scopes_json::text) LIKE '%full_access_as_app%'
      OR lower(e.scopes_json::text) LIKE '%files.readwrite.all%'
      OR lower(e.scopes_json::text) LIKE '%files.readwrite%'
      OR lower(e.scopes_json::text) LIKE '%sites.readwrite.all%'
      OR lower(e.scopes_json::text) LIKE '%user.readwrite.all%'
      OR lower(e.scopes_json::text) LIKE '%offline_access%'
    ) FILTER (WHERE e.signal_kind = 'oauth_grant') AS has_privileged_scope,
    bool_or(
      lower(e.scopes_json::text) LIKE '%mail.%'
      OR lower(e.scopes_json::text) LIKE '%files.%'
      OR lower(e.scopes_json::text) LIKE '%calendar.%'
      OR lower(e.scopes_json::text) LIKE '%readwrite%'
      OR lower(e.scopes_json::text) LIKE '%sites.read%'
    ) FILTER (WHERE e.signal_kind = 'oauth_grant') AS has_confidential_scope
  FROM active_events e
  GROUP BY e.saas_app_id
),
primary_binding AS (
  SELECT
    b.saas_app_id,
    b.connector_kind,
    b.connector_source_name,
    b.binding_source,
    b.confidence
  FROM saas_app_bindings b
  WHERE b.is_primary
)
SELECT
  sa.id,
  COALESCE(go.owner_identity_id, 0)::bigint AS owner_identity_id,
  COALESCE(go.business_criticality, 'unknown')::text AS business_criticality,
  COALESCE(go.data_classification, 'unknown')::text AS data_classification,
  COALESCE(ac.actors_30d, 0)::bigint AS actors_30d,
  COALESCE(sf.has_privileged_scope, false)::boolean AS has_privileged_scope,
  COALESCE(sf.has_confidential_scope, false)::boolean AS has_confidential_scope,
  COALESCE(pb.connector_kind, '')::text AS binding_connector_kind,
  COALESCE(pb.connector_source_name, '')::text AS binding_connector_source_name,
  COALESCE(pb.binding_source, '')::text AS binding_source,
  COALESCE(pb.confidence, 0)::real AS binding_confidence
FROM saas_apps sa
LEFT JOIN saas_app_governance_overrides go ON go.saas_app_id = sa.id
LEFT JOIN actor_counts ac ON ac.saas_app_id = sa.id
LEFT JOIN scope_flags sf ON sf.saas_app_id = sa.id
LEFT JOIN primary_binding pb ON pb.saas_app_id = sa.id
WHERE EXISTS (
  SELECT 1
  FROM saas_app_sources sas
  WHERE sas.saas_app_id = sa.id
    AND sas.expired_at IS NULL
    AND sas.last_observed_run_id IS NOT NULL
)
ORDER BY sa.id ASC
`

type ListSaaSAppPostureInputsRow struct {
	ID                         int64   `json:"id"`
	OwnerIdentityID            int64   `json:"owner_identity_id"`
	BusinessCriticality        string  `json:"business_criticality"`
	DataClassification         string  `json:"data_classification"`
	Actors30d                  int64   `json:"actors_30d"`
	HasPrivilegedScope         bool    `json:"has_privileged_scope"`
	HasConfidentialScope       bool    `json:"has_confidential_scope"`
	BindingConnectorKind       string  `json:"binding_connector_kind"`
	BindingConnectorSourceName string  `json:"binding_connector_source_name"`
	BindingSource              string  `json:"binding_source"`
	BindingConfidence          float32 `json:"binding_confidence"`
}

func (q *Queries) ListSaaSAppPostureInputs(ctx context.Context) ([]ListSaaSAppPostureInputsRow, error) {
	rows, err := q.db.Query(ctx, listSaaSAppPostureInputs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSaaSAppPostureInputsRow
	for rows.Next() {
		var i ListSaaSAppPostureInputsRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerIdentityID,
			&i.BusinessCriticality,
			&i.DataClassification,
			&i.Actors30d,
			&i.HasPrivilegedScope,
			&i.HasConfidentialScope,
			&i.BindingConnectorKind,
			&i.BindingConnectorSourceName,
			&i.BindingSource,
			&i.BindingConfidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSaaSAppsPageByFilters = `-- name: ListSaaSAppsPageByFilters :many
WITH configured_sources AS (
  SELECT
    k.kind AS source_kind,
    n.name AS source_name
  FROM unnest($8::text[]) WITH ORDINALITY AS k(kind, ord)
  JOIN unnest($9::text[]) WITH ORDINALITY AS n(name, ord) USING (ord)
)
SELECT
  sa.id, sa.canonical_key, sa.display_name, sa.primary_domain, sa.vendor_name, sa.managed_state, sa.managed_reason, sa.bound_connector_kind, sa.bound_connector_source_name, sa.risk_score, sa.risk_level, sa.suggested_business_criticality, sa.suggested_data_classification, sa.first_seen_at, sa.last_seen_at, sa.created_at, sa.updated_at,
  go.owner_identity_id,
  COALESCE(owner.display_name, '') AS owner_display_name,
  COALESCE(owner.primary_email, '') AS owner_primary_email,
  COALESCE(actor_stats.actors_30d, 0)::bigint AS actors_30d
FROM saas_apps sa
LEFT JOIN saas_app_governance_overrides go ON go.saas_app_id = sa.id
LEFT JOIN identities owner ON owner.id = go.owner_identity_id
LEFT JOIN LATERAL (
  SELECT
    count(DISTINCT COALESCE(NULLIF(trim(e.actor_external_id), ''), NULLIF(lower(trim(e.actor_email)), ''))) AS actors_30d
  FROM saas_app_events e
  WHERE e.saas_app_id = sa.id
    AND e.expired_at IS NULL
    AND e.last_observed_run_id IS NOT NULL
    AND e.observed_at >= now() - interval '30 days'
) actor_stats ON TRUE
WHERE EXISTS (
  SELECT 1
  FROM saas_app_sources sas
  JOIN configured_sources cs
    ON cs.source_kind = sas.source_kind
   AND cs.source_name = sas.source_name
  WHERE sas.saas_app_id = sa.id
    AND sas.expired_at IS NULL
    AND sas.last_observed_run_id IS NOT NULL
    AND (
      $1::text = ''
      OR sas.source_kind = $1::text
    )
    AND (
      $2::text = ''
      OR sas.source_name = $2::text
    )
)
  AND (
    $3::text = ''
    OR sa.managed_state = $3::text
  )
  AND (
    $4::text = ''
    OR sa.risk_level = $4::text
  )
  AND (
    $5::text = ''
    OR sa.display_name ILIKE ('%' || $5::text || '%')
    OR sa.primary_domain ILIKE ('%' || $5::text || '%')
    OR sa.vendor_name ILIKE ('%' || $5::text || '%')
    OR sa.canonical_key ILIKE ('%' || $5::text || '%')
  )
ORDER BY
  sa.risk_score DESC,
  sa.last_seen_at DESC,
  lower(COALESCE(NULLIF(trim(sa.display_name), ''), sa.canonical_key)) ASC,
  sa.id ASC
LIMIT $7::int
OFFSET $6::int
`

type ListSaaSAppsPageByFiltersParams struct {
	SourceKind            string   `json:"source_kind"`
	SourceName            string   `json:"source_name"`
	ManagedState          string   `json:"managed_state"`
	RiskLevel             string   `json:"risk_level"`
	Query                 string   `json:"query"`
	PageOffset            int32    `json:"page_offset"`
	PageLimit             int32    `json:"page_limit"`
	ConfiguredSourceKinds []string `json:"configured_source_kinds"`
	ConfiguredSourceNames []string `json:"configured_source_names"`
}

type ListSaaSAppsPageByFiltersRow struct {
	ID                           int64              `json:"id"`
	CanonicalKey                 string             `json:"canonical_key"`
	DisplayName                  string             `json:"display_name"`
	PrimaryDomain                string             `json:"primary_domain"`
	VendorName                   string             `json:"vendor_name"`
	ManagedState                 string             `json:"managed_state"`
	ManagedReason                string             `json:"managed_reason"`
	BoundConnectorKind           string             `json:"bound_connector_kind"`
	BoundConnectorSourceName     string             `json:"bound_connector_source_name"`
	RiskScore                    int32              `json:"risk_score"`
	RiskLevel                    string             `json:"risk_level"`
	SuggestedBusinessCriticality string             `json:"suggested_business_criticality"`
	SuggestedDataClassification  string             `json:"suggested_data_classification"`
	FirstSeenAt                  pgtype.Timestamptz `json:"first_seen_at"`
	LastSeenAt                   pgtype.Timestamptz `json:"last_seen_at"`
	CreatedAt                    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                    pgtype.Timestamptz `json:"updated_at"`
	OwnerIdentityID              pgtype.Int8        `json:"owner_identity_id"`
	OwnerDisplayName             string             `json:"owner_display_name"`
	OwnerPrimaryEmail            string             `json:"owner_primary_email"`
	Actors30d                    int64              `json:"actors_30d"`
}

func (q *Queries) ListSaaSAppsPageByFilters(ctx context.Context, arg ListSaaSAppsPageByFiltersParams) ([]ListSaaSAppsPageByFiltersRow, error) {
	rows, err := q.db.Query(ctx, listSaaSAppsPageByFilters,
		arg.SourceKind,
		arg.SourceName,
		arg.ManagedState,
		arg.RiskLevel,
		arg.Query,
		arg.PageOffset,
		arg.PageLimit,
		arg.ConfiguredSourceKinds,
		arg.ConfiguredSourceNames,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSaaSAppsPageByFiltersRow
	for rows.Next() {
		var i ListSaaSAppsPageByFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.CanonicalKey,
			&i.DisplayName,
			&i.PrimaryDomain,
			&i.VendorName,
			&i.ManagedState,
			&i.ManagedReason,
			&i.BoundConnectorKind,
			&i.BoundConnectorSourceName,
			&i.RiskScore,
			&i.RiskLevel,
			&i.SuggestedBusinessCriticality,
			&i.SuggestedDataClassification,
			&i.FirstSeenAt,
			&i.LastSeenAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerIdentityID,
			&i.OwnerDisplayName,
			&i.OwnerPrimaryEmail,
			&i.Actors30d,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSaaSAppPosture = `-- name: UpdateSaaSAppPosture :exec
UPDATE saas_apps
SET
  managed_state = $1::text,
  managed_reason = $2::text,
  bound_connector_kind = $3::text,
  bound_connector_source_name = $4::text,
  risk_score = $5::int,
  risk_level = $6::text,
  suggested_business_criticality = $7::text,
  suggested_data_classification = $8::text,
  updated_at = now()
WHERE id = $9::bigint
`

type UpdateSaaSAppPostureParams struct {
	ManagedState                 string `json:"managed_state"`
	ManagedReason                string `json:"managed_reason"`
	BoundConnectorKind           string `json:"bound_connector_kind"`
	BoundConnectorSourceName     string `json:"bound_connector_source_name"`
	RiskScore                    int32  `json:"risk_score"`
	RiskLevel                    string `json:"risk_level"`
	SuggestedBusinessCriticality string `json:"suggested_business_criticality"`
	SuggestedDataClassification  string `json:"suggested_data_classification"`
	ID                           int64  `json:"id"`
}

func (q *Queries) UpdateSaaSAppPosture(ctx context.Context, arg UpdateSaaSAppPostureParams) error {
	_, err := q.db.Exec(ctx, updateSaaSAppPosture,
		arg.ManagedState,
		arg.ManagedReason,
		arg.BoundConnectorKind,
		arg.BoundConnectorSourceName,
		arg.RiskScore,
		arg.RiskLevel,
		arg.SuggestedBusinessCriticality,
		arg.SuggestedDataClassification,
		arg.ID,
	)
	return err
}

const upsertSaaSAppsBulk = `-- name: UpsertSaaSAppsBulk :execrows
WITH input AS (
  SELECT
    i,
    ($1::text[])[i] AS canonical_key,
    ($2::text[])[i] AS display_name,
    ($3::text[])[i] AS primary_domain,
    ($4::text[])[i] AS vendor_name,
    ($5::timestamptz[])[i] AS first_seen_at,
    ($6::timestamptz[])[i] AS last_seen_at
  FROM generate_subscripts($1::text[], 1) AS s(i)
),
dedup AS (
  SELECT DISTINCT ON (canonical_key)
    canonical_key,
    display_name,
    primary_domain,
    vendor_name,
    first_seen_at,
    last_seen_at
  FROM input
  ORDER BY canonical_key, i DESC
)
INSERT INTO saas_apps (
  canonical_key,
  display_name,
  primary_domain,
  vendor_name,
  first_seen_at,
  last_seen_at,
  updated_at
)
SELECT
  d.canonical_key,
  d.display_name,
  d.primary_domain,
  d.vendor_name,
  COALESCE(d.first_seen_at, now()),
  COALESCE(d.last_seen_at, now()),
  now()
FROM dedup d
ON CONFLICT (canonical_key) DO UPDATE SET
  display_name = CASE
    WHEN trim(EXCLUDED.display_name) <> '' THEN EXCLUDED.display_name
    ELSE saas_apps.display_name
  END,
  primary_domain = CASE
    WHEN trim(EXCLUDED.primary_domain) <> '' THEN EXCLUDED.primary_domain
    ELSE saas_apps.primary_domain
  END,
  vendor_name = CASE
    WHEN trim(EXCLUDED.vendor_name) <> '' THEN EXCLUDED.vendor_name
    ELSE saas_apps.vendor_name
  END,
  first_seen_at = LEAST(saas_apps.first_seen_at, COALESCE(EXCLUDED.first_seen_at, saas_apps.first_seen_at)),
  last_seen_at = GREATEST(saas_apps.last_seen_at, COALESCE(EXCLUDED.last_seen_at, saas_apps.last_seen_at)),
  updated_at = now()
`

type UpsertSaaSAppsBulkParams struct {
	CanonicalKeys  []string             `json:"canonical_keys"`
	DisplayNames   []string             `json:"display_names"`
	PrimaryDomains []string             `json:"primary_domains"`
	VendorNames    []string             `json:"vendor_names"`
	FirstSeenAts   []pgtype.Timestamptz `json:"first_seen_ats"`
	LastSeenAts    []pgtype.Timestamptz `json:"last_seen_ats"`
}

func (q *Queries) UpsertSaaSAppsBulk(ctx context.Context, arg UpsertSaaSAppsBulkParams) (int64, error) {
	result, err := q.db.Exec(ctx, upsertSaaSAppsBulk,
		arg.CanonicalKeys,
		arg.DisplayNames,
		arg.PrimaryDomains,
		arg.VendorNames,
		arg.FirstSeenAts,
		arg.LastSeenAts,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
